/*
 * ATTENTION: The "eval" devtool has been used (maybe by default in mode: "development").
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
/******/ (() => { // webpackBootstrap
/******/ 	"use strict";
/******/ 	var __webpack_modules__ = ({

/***/ "./node_modules/@pixi-essentials/cull/lib/cull.es.js":
/*!***********************************************************!*\
  !*** ./node_modules/@pixi-essentials/cull/lib/cull.es.js ***!
  \***********************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"Cull\": () => (/* binding */ Cull)\n/* harmony export */ });\n/* harmony import */ var _pixi_math__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @pixi/math */ \"./node_modules/@pixi/math/dist/esm/math.mjs\");\n/* eslint-disable */\n \n/*!\n * @pixi-essentials/cull - v1.0.12\n * Compiled Wed, 17 Mar 2021 16:10:19 UTC\n *\n * @pixi-essentials/cull is licensed under the MIT License.\n * http://www.opensource.org/licenses/mit-license\n * \n * Copyright 2019-2020, Shukant Pal <shukantpal@outlook.com>, All Rights Reserved\n */\n\n\nconst tempRect = new _pixi_math__WEBPACK_IMPORTED_MODULE_0__.Rectangle();\n\n/**\n * The culling options for {@code Cull}.\n *\n * @ignore\n * @public\n */\n\n\n\n\n\n\n/**\n * Provides a simple, configurable mechanism for culling a subtree of your scene graph.\n *\n * If your scene graph is not static, culling needs to be done before rendering. You\n * can run it on the `prerender` event fired by the renderer.\n *\n * @public\n */\nclass Cull\n{\n    \n    \n    \n\n    /**\n     * @param options\n     * @param [options.recursive] - whether culling should be recursive\n     * @param [options.toggle='renderable'] - which property of display-object was be set to indicate\n     *      its culling state. It should be one of `renderable`, `visible`.\n     */\n    constructor(options = {})\n    {\n        this._recursive = typeof options.recursive === 'boolean' ? options.recursive : true;\n        this._toggle = options.toggle || 'visible';\n        this._targetList = new Set();\n    }\n\n    /**\n     * Adds a display-object to the culling list\n     *\n     * @param target - the display-object to be culled\n     * @return this\n     */\n    add(target)\n    {\n        this._targetList.add(target);\n\n        return this;\n    }\n\n    /**\n     * Adds all the display-objects to the culling list\n     *\n     * @param targets - the display-objects to be culled\n     * @return this\n     */\n    addAll(targets)\n    {\n        for (let i = 0, j = targets.length; i < j; i++)\n        {\n            this._targetList.add(targets[i]);\n        }\n\n        return this;\n    }\n\n    /**\n     * Removes the display-object from the culling list\n     *\n     * @param target - the display-object to be removed\n     * @return this\n     */\n    remove(target)\n    {\n        this._targetList.delete(target);\n\n        return this;\n    }\n\n    /**\n     * Removes all the passed display-objects from the culling list\n     *\n     * @param targets - the display-objects to be removed\n     * @return this\n     */\n    removeAll(targets)\n    {\n        for (let i = 0, j = targets.length; i < j; i++)\n        {\n            this._targetList.delete(targets[i]);\n        }\n\n        return this;\n    }\n\n    /**\n     * Clears the culling list\n     *\n     * @return this\n     */\n    clear()\n    {\n        this._targetList.clear();\n\n        return this;\n    }\n\n    /**\n     * @param rect - the rectangle outside of which display-objects should be culled\n     * @param skipUpdate - whether to skip unculling, transform update, bounds calculation. It is\n     *  highly recommended you enable this by calling _this.uncull()_ and _root.getBounds(false)_ manually\n     *  before your render loop.\n     * @return this\n     */\n    cull(rect, skipUpdate = false)\n    {\n        if (!skipUpdate)\n        {\n            this.uncull();\n        }\n\n        this._targetList.forEach((target) =>\n        {\n            if (!skipUpdate)\n            {\n                // Update transforms, bounds of display-objects in this target's subtree\n                target.getBounds(false, tempRect);\n            }\n\n            if (this._recursive)\n            {\n                this.cullRecursive(rect, target, skipUpdate);\n            }\n            else\n            {\n                // NOTE: If skipUpdate is false, then tempRect already contains the bounds of the target\n                if (skipUpdate)\n                {\n                    target._bounds.getRectangle(rect);\n                }\n\n                target[this._toggle] = tempRect.right > rect.left\n                    && tempRect.left < rect.right\n                    && tempRect.bottom > rect.top\n                    && tempRect.top < rect.bottom;\n            }\n        });\n\n        return this;\n    }\n\n    /**\n     * Sets all display-objects to the unculled state.\n     *\n     * This happens regardless of whether the culling toggle was set by {@code this.cull} or manually. This\n     * is why it is recommended to one of `visible` or `renderable` for normal use and the other for culling.\n     *\n     * @return this\n     */\n    uncull()\n    {\n        this._targetList.forEach((target) =>\n        {\n            if (this._recursive)\n            {\n                this.uncullRecursive(target);\n            }\n            else\n            {\n                target[this._toggle] = false;\n            }\n        });\n\n        return this;\n    }\n\n    /**\n     * Recursively culls the subtree of {@code displayObject}.\n     *\n     * @param rect - the visiblity rectangle\n     * @param displayObject - the root of the subtree to cull\n     * @param skipUpdate - whether to skip bounds calculation. However, transforms are expected to be updated by the caller.\n     */\n     cullRecursive(rect, displayObject, skipUpdate)\n    {\n        // NOTE: getBounds can skipUpdate because updateTransform is invoked before culling.\n        const bounds = skipUpdate\n            ? displayObject._bounds.getRectangle(tempRect)\n            : displayObject.getBounds(true, tempRect);\n\n        displayObject[this._toggle] = bounds.right > rect.left\n            && bounds.left < rect.right\n            && bounds.bottom > rect.top\n            && bounds.top < rect.bottom;\n\n        const fullyVisible = bounds.left >= rect.left\n            && bounds.top >= rect.top\n            && bounds.right <= rect.right\n            && bounds.bottom <= rect.bottom;\n\n        // Only cull children if this display-object is *not* fully-visible. It is expected that the bounds\n        // of children lie inside of its own. Hence, further culling is only required if the display-object\n        // intersects with the boundaries of \"rect\". Otherwise, if the object is fully outside/inside the\n        // screen, the children don't need to be evaluated as they are presumed to be unculled.\n        if (!fullyVisible\n                && displayObject[this._toggle]\n                && (displayObject ).children\n                && (displayObject ).children.length)\n        {\n            const children = (displayObject ).children;\n\n            for (let i = 0, j = children.length; i < j; i++)\n            {\n                this.cullRecursive(rect, children[i]);\n            }\n        }\n    }\n\n    /**\n     * Recursively unculls the subtree of {@code displayObject}.\n     *\n     * @param displayObject\n     */\n     uncullRecursive(displayObject)\n    {\n        displayObject[this._toggle] = true;\n\n        if ((displayObject ).children && (displayObject ).children.length)\n        {\n            const children = (displayObject ).children;\n\n            for (let i = 0, j = children.length; i < j; i++)\n            {\n                this.uncullRecursive(children[i]);\n            }\n        }\n    }\n}\n\n\n//# sourceMappingURL=cull.es.js.map\n\n\n//# sourceURL=webpack://sv-editor2/./node_modules/@pixi-essentials/cull/lib/cull.es.js?");

/***/ }),

/***/ "./parser.js":
/*!*******************!*\
  !*** ./parser.js ***!
  \*******************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _modules_Notes_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./modules/Notes.mjs */ \"./modules/Notes.mjs\");\n/* harmony import */ var _modules_codecs_osuCodec_mjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./modules/codecs/osuCodec.mjs */ \"./modules/codecs/osuCodec.mjs\");\n\r\n\r\n// console.log(osu);\r\n\r\n// PIXI setup\r\n/*PIXI.BitmapFont.from('Arial', {\r\n  fontName: \"Arial\",\r\n  fontSize: 12,\r\n  chars: [['a', 'z'], ['A', 'Z'], \"!@#$%^&*()~{}[],.<>/ \"],\r\n});*/\r\n\r\n// example file\r\nfetch(\"./assets/Smigonaut_-_Shower_Beer.zip\").then(x => x.blob()).then(unzip).then(parseFiles);\r\n\r\nlet selectFile;\r\nfunction parseFiles(files){\r\n  console.log(files);\r\n  selectFile?.remove();\r\n  // create a secondary select element to select the specific difficulty of\r\n  // the beatmap that we want to edit\r\n  selectFile = document.createElement('select');\r\n  let defaultOption = document.createElement('option');\r\n  defaultOption.innerText = '(select a file)';\r\n  selectFile.append(defaultOption);\r\n  files.forEach((file, i) => {\r\n    if(file.name.endsWith('.osu')){\r\n      const option = document.createElement('option');\r\n      option.value = i;\r\n      option.innerText = file.name;\r\n      selectFile.append(option);\r\n    }\r\n  });\r\n  selectFile.addEventListener('change', () => {\r\n    // console.log(selectFile.value);\r\n    const file = files[selectFile.value];\r\n    const reader = new FileReader();\r\n    reader.addEventListener('load', () => {\r\n      let _start = performance.now();\r\n      const data = reader.result;\r\n      const proj = _modules_codecs_osuCodec_mjs__WEBPACK_IMPORTED_MODULE_1__.decode(data);\r\n      proj.loadResources(files);\r\n      console.log(proj);\r\n      project = proj; // expose to global scope\r\n      project.codec = _modules_codecs_osuCodec_mjs__WEBPACK_IMPORTED_MODULE_1__; // expose more stuff to global scope\r\n      console.log(0|(performance.now()-_start), \"ms file load time\");\r\n      _start = performance.now();\r\n      project.openEditor();\r\n      console.log(0|(performance.now()-_start), \"ms to open editor\");\r\n    });\r\n    reader.readAsText(file);\r\n    document.getElementById(\"loader\").style.display = \"none\";\r\n    // selectFile.remove();\r\n    // inputFile.remove();\r\n  });\r\n  document.getElementById(\"loader\").append(selectFile);\r\n}\r\n\r\nasync function unzip(zipfile){\r\n  // see https://stuk.github.io/jszip/documentation/examples/read-local-file-api.html\r\n  // convert to file to treat as if it were a folder upload :: https://stackoverflow.com/a/42589217\r\n  const jsZip = await Promise.all((await JSZip.loadAsync(zipfile))\r\n    .filter(()=>true)\r\n    .map(async n => new File([await n.async('blob')], n.name))\r\n  );\r\n  return jsZip;\r\n}\r\n\r\n// folder input\r\n(() => {\r\n  let inputFile = document.getElementById('folder');\r\n  inputFile.addEventListener('change', (event) => {\r\n    // console.log(event.srcElement.files);\r\n    const files = Array.from(event.target.files);\r\n    if(files.length > 0){\r\n      parseFiles(files);\r\n    }\r\n  });\r\n})();\r\n\r\n// zip file input\r\n(() => {\r\n  let inputFile = document.getElementById('zip');\r\n  inputFile.addEventListener('change', async (event) => {\r\n    // console.log(event.srcElement.files);\r\n    const zipfile = event.target.files[0];\r\n    if (!zipfile) return;\r\n    // if we successfully loaded the zip, use jszip to unpack files\r\n    \r\n    parseFiles(await unzip(zipfile));\r\n  });\r\n})();\r\n\r\n(() => {\r\n  const rad = document.getElementsByClassName(\"fileType\");\r\n  for (let i = 0; i < rad.length; i++) {\r\n    rad[i].addEventListener(\"change\", () => {\r\n      if (rad[i].value === \"folder\") {\r\n        document.getElementById(\"zipSelector\").style.display = \"none\";\r\n        document.getElementById(\"folderSelector\").style.display = \"block\";\r\n      } else {\r\n        document.getElementById(\"zipSelector\").style.display = \"block\";\r\n        document.getElementById(\"folderSelector\").style.display = \"none\";\r\n      }\r\n    });\r\n  }\r\n})();\r\n\n\n//# sourceURL=webpack://sv-editor2/./parser.js?");

/***/ }),

/***/ "./modules/Constants.mjs":
/*!*******************************!*\
  !*** ./modules/Constants.mjs ***!
  \*******************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"MouseButtons\": () => (/* binding */ MouseButtons)\n/* harmony export */ });\n\r\n\r\nconst MouseButtons = {\r\n  LEFT: 0,\r\n  MIDDLE: 1,\r\n  RIGHT: 2,\r\n};\r\n\r\n\r\n\n\n//# sourceURL=webpack://sv-editor2/./modules/Constants.mjs?");

/***/ }),

/***/ "./modules/Function.mjs":
/*!******************************!*\
  !*** ./modules/Function.mjs ***!
  \******************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"Function\": () => (/* binding */ Function),\n/* harmony export */   \"Functions\": () => (/* binding */ Functions),\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n// its literally a function\r\n\r\nclass Function {\r\n  // Square, Sine, Cosine, Triangle\r\n  // static Quadratic = new EasingFunction(\"Quadratic\", (x, y=x, t=0) => x+(y-x)*(t**2));\r\n  constructor(name, extraParameters, f, g){\r\n    this.name = name;\r\n    this.id = Symbol(name);\r\n    this.parameterNames = [\"t0\", \"x0\", ...extraParameters];\r\n    // this.parameters = this.parameterNames.map(x => 0);\r\n    this.func = f;\r\n    this.getDetails = g;\r\n  }\r\n  getLabel(params){\r\n    return this.getDetails(...params);\r\n  }\r\n  generateParameters(){\r\n    return this.parameterNames.map(x => 0);\r\n  }\r\n  evaluate(t){\r\n    return this.func(...arguments);\r\n  }\r\n  isConstant(){\r\n    return this.name === \"Constant\";\r\n  }\r\n}\r\n\r\nconst Functions = {\r\n  Constant: new Function(\"Constant\", [],\r\n    (t, t0, x0) => x0,\r\n    (t0, x0) => `${x0.toPrecision(2)}`),\r\n  Linear: new Function(\"Linear\", [\"x1\", \"x2\"],\r\n    (t, t0, x0, x, y) => (x0+x*(1-t)+y*t),\r\n    (t0, x0, x, y) => `${(x+x0).toPrecision(2)} to ${(y+x0).toPrecision(2)}`),\r\n  Sine: new Function(\"Sine\", [\"A\", \"f\"],\r\n    (t, t0, x0, A, f) => x0+A*Math.sin(((t+t0)*Math.PI*2*f)),\r\n    (t0, x0, A, f) => `sin ${(x0-A).toPrecision(2)} to ${(x0+A).toPrecision(2)} @ ${f.toPrecision(2)}Hz`),\r\n  Square: new Function(\"Square\", [\"A\", \"f\", \"DC\"],\r\n    (t, t0, x0, A, f, DC) => x0+((((t+t0)*f)%1)<DC?A:0),\r\n    (t0, x0, A, f, DC) => `sqr ${(x0).toPrecision(2)} to ${(x0+A).toPrecision(2)} @ ${f.toPrecision(2)}Hz ${(DC*100).toPrecision(3)}%`),\r\n};\r\nObject.entries(Functions).forEach(([name, func]) => {\r\n  Object.defineProperty(Function, name, {\r\n    enumerable: false,\r\n    configurable: false,\r\n    writable: false,\r\n    value: func\r\n  });\r\n});\r\n\r\n/*\r\nTODO: n point splines ??\r\nhttps://github.com/Pomax/bezierjs/blob/master/dist/bezier.cjs\r\nhttps://gist.github.com/nicholaswmin/c2661eb11cad5671d816\r\n*/\r\n\r\n\r\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (Function);\r\n\n\n//# sourceURL=webpack://sv-editor2/./modules/Function.mjs?");

/***/ }),

/***/ "./modules/LongNote.mjs":
/*!******************************!*\
  !*** ./modules/LongNote.mjs ***!
  \******************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"LongNote\": () => (/* binding */ LongNote),\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony import */ var _Note_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Note.mjs */ \"./modules/Note.mjs\");\n\r\n\r\n// TODO: hmm having svblock.duration while notes use endtime (from osu file format) does not very good\r\n\r\nclass LongNote extends _Note_mjs__WEBPACK_IMPORTED_MODULE_0__[\"default\"] {\r\n  constructor(x=0, t=0, endTime=1000){\r\n    super(x, t);\r\n    this.t$ = endTime; // using end anchor notation from regex for \"end time\"\r\n  }\r\n  setEnd(t){\r\n    this.t$ = t;\r\n  }\r\n  setTime(start, end){\r\n    this.t = start;\r\n    this.t$ = end;\r\n  }\r\n  getEnd(){\r\n    return this.t$;\r\n  }\r\n  clone(){\r\n    return new LongNote(this.x, this.y, this.t$);\r\n  }\r\n}\r\n\r\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (LongNote);\r\n\r\n\n\n//# sourceURL=webpack://sv-editor2/./modules/LongNote.mjs?");

/***/ }),

/***/ "./modules/Note.mjs":
/*!**************************!*\
  !*** ./modules/Note.mjs ***!
  \**************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"Note\": () => (/* binding */ Note),\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\nclass Note {\r\n  constructor(x=0, t=0){\r\n    this.x = x;\r\n    this.t = t;\r\n    // this.hs = 0;\r\n    // this.sample // TODO: these maybe?\r\n  }\r\n  getStart(){\r\n    return this.t;\r\n  }\r\n  getEnd(){\r\n    return this.t;\r\n  }\r\n  setStart(t){\r\n    this.t = t;\r\n  }\r\n  setEnd(t){\r\n    this.t = t;\r\n  }\r\n  setTime(t, t$=0){\r\n    this.t = t;\r\n    // do we even need setStart/setEnd??\r\n  }\r\n  clone(){\r\n    return new Note(this.x, this.y);\r\n  }\r\n}\r\n\r\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (Note);\r\n\r\n\n\n//# sourceURL=webpack://sv-editor2/./modules/Note.mjs?");

/***/ }),

/***/ "./modules/Notes.mjs":
/*!***************************!*\
  !*** ./modules/Notes.mjs ***!
  \***************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"LongNote\": () => (/* reexport safe */ _LongNote_mjs__WEBPACK_IMPORTED_MODULE_1__[\"default\"]),\n/* harmony export */   \"Note\": () => (/* reexport safe */ _Note_mjs__WEBPACK_IMPORTED_MODULE_0__[\"default\"]),\n/* harmony export */   \"SvBlock\": () => (/* reexport safe */ _SvBlock_mjs__WEBPACK_IMPORTED_MODULE_2__[\"default\"])\n/* harmony export */ });\n/* harmony import */ var _Note_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Note.mjs */ \"./modules/Note.mjs\");\n/* harmony import */ var _LongNote_mjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./LongNote.mjs */ \"./modules/LongNote.mjs\");\n/* harmony import */ var _SvBlock_mjs__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./SvBlock.mjs */ \"./modules/SvBlock.mjs\");\n\r\n\r\n\r\n\r\n\r\n\n\n//# sourceURL=webpack://sv-editor2/./modules/Notes.mjs?");

/***/ }),

/***/ "./modules/OutlineFilter.mjs":
/*!***********************************!*\
  !*** ./modules/OutlineFilter.mjs ***!
  \***********************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"OutlineFilter\": () => (/* binding */ OutlineFilter)\n/* harmony export */ });\n/*!\r\n * @pixi/filter-outline - v4.2.0\r\n * Compiled Fri, 05 Aug 2022 19:53:35 UTC\r\n *\r\n * @pixi/filter-outline is licensed under the MIT License.\r\n * http://www.opensource.org/licenses/mit-license\r\n */\r\nconst {Filter} = PIXI; // import { Filter } from '@pixi/core';\r\nconst {rgb2hex, hex2rgb} = PIXI.utils; // import { rgb2hex, hex2rgb } from '@pixi/utils';\r\n\r\n/*! *****************************************************************************\r\nCopyright (c) Microsoft Corporation.\r\n\r\nPermission to use, copy, modify, and/or distribute this software for any\r\npurpose with or without fee is hereby granted.\r\n\r\nTHE SOFTWARE IS PROVIDED \"AS IS\" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH\r\nREGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY\r\nAND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,\r\nINDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM\r\nLOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR\r\nOTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR\r\nPERFORMANCE OF THIS SOFTWARE.\r\n***************************************************************************** */\r\n/* global Reflect, Promise */\r\n\r\nvar extendStatics = function(d, b) {\r\n    extendStatics = Object.setPrototypeOf ||\r\n        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\r\n        function (d, b) { for (var p in b) { if (Object.prototype.hasOwnProperty.call(b, p)) { d[p] = b[p]; } } };\r\n    return extendStatics(d, b);\r\n};\r\n\r\nfunction __extends(d, b) {\r\n    extendStatics(d, b);\r\n    function __() { this.constructor = d; }\r\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\r\n}\r\n\r\nvar vertex = \"attribute vec2 aVertexPosition;\\nattribute vec2 aTextureCoord;\\n\\nuniform mat3 projectionMatrix;\\n\\nvarying vec2 vTextureCoord;\\n\\nvoid main(void)\\n{\\n    gl_Position = vec4((projectionMatrix * vec3(aVertexPosition, 1.0)).xy, 0.0, 1.0);\\n    vTextureCoord = aTextureCoord;\\n}\";\r\n\r\nvar fragment = \"varying vec2 vTextureCoord;\\nuniform sampler2D uSampler;\\n\\nuniform vec2 thickness;\\nuniform vec4 outlineColor;\\nuniform vec4 filterClamp;\\n\\nconst float DOUBLE_PI = 3.14159265358979323846264 * 2.;\\n\\nvoid main(void) {\\n    vec4 ownColor = texture2D(uSampler, vTextureCoord);\\n    vec4 curColor;\\n    float maxAlpha = 0.;\\n    vec2 displaced;\\n    for (float angle = 0.; angle <= DOUBLE_PI; angle += ${angleStep}) {\\n        displaced.x = vTextureCoord.x + thickness.x * cos(angle);\\n        displaced.y = vTextureCoord.y + thickness.y * sin(angle);\\n        curColor = texture2D(uSampler, clamp(displaced, filterClamp.xy, filterClamp.zw));\\n        maxAlpha = max(maxAlpha, curColor.a);\\n    }\\n    float resultAlpha = max(maxAlpha, ownColor.a);\\n    gl_FragColor = vec4((ownColor.rgb + outlineColor.rgb * (1. - ownColor.a)) * resultAlpha, resultAlpha);\\n}\\n\";\r\n\r\n/**\r\n * OutlineFilter, originally by mishaa\r\n * http://www.html5gamedevs.com/topic/10640-outline-a-sprite-change-certain-colors/?p=69966\r\n * http://codepen.io/mishaa/pen/emGNRB<br>\r\n * ![original](../tools/screenshots/dist/original.png)![filter](../tools/screenshots/dist/outline.png)\r\n *\r\n * @class\r\n * @extends PIXI.Filter\r\n * @memberof PIXI.filters\r\n * @see {@link https://www.npmjs.com/package/@pixi/filter-outline|@pixi/filter-outline}\r\n * @see {@link https://www.npmjs.com/package/pixi-filters|pixi-filters} *\r\n * @example\r\n *  someSprite.filters = [new OutlineFilter(2, 0x99ff99)];\r\n */\r\nvar OutlineFilter = /** @class */ (function (_super) {\r\n    __extends(OutlineFilter, _super);\r\n    /**\r\n     * @param {number} [thickness=1] - The tickness of the outline. Make it 2 times more for resolution 2\r\n     * @param {number} [color=0x000000] - The color of the outline.\r\n     * @param {number} [quality=0.1] - The quality of the outline from `0` to `1`, using a higher quality\r\n     *        setting will result in slower performance and more accuracy.\r\n     */\r\n    function OutlineFilter(thickness, color, quality) {\r\n        if (thickness === void 0) { thickness = 1; }\r\n        if (color === void 0) { color = 0x000000; }\r\n        if (quality === void 0) { quality = 0.1; }\r\n        var _this = _super.call(this, vertex, fragment.replace(/\\$\\{angleStep\\}/, OutlineFilter.getAngleStep(quality))) || this;\r\n        _this._thickness = 1;\r\n        _this.uniforms.thickness = new Float32Array([0, 0]);\r\n        _this.uniforms.outlineColor = new Float32Array([0, 0, 0, 1]);\r\n        Object.assign(_this, { thickness: thickness, color: color, quality: quality });\r\n        return _this;\r\n    }\r\n    /**\r\n     * Get the angleStep by quality\r\n     * @private\r\n     */\r\n    OutlineFilter.getAngleStep = function (quality) {\r\n        var samples = Math.max(quality * OutlineFilter.MAX_SAMPLES, OutlineFilter.MIN_SAMPLES);\r\n        return (Math.PI * 2 / samples).toFixed(7);\r\n    };\r\n    OutlineFilter.prototype.apply = function (filterManager, input, output, clear) {\r\n        this.uniforms.thickness[0] = this._thickness / input._frame.width;\r\n        this.uniforms.thickness[1] = this._thickness / input._frame.height;\r\n        filterManager.applyFilter(this, input, output, clear);\r\n    };\r\n    Object.defineProperty(OutlineFilter.prototype, \"color\", {\r\n        /**\r\n         * The color of the glow.\r\n         * @default 0x000000\r\n         */\r\n        get: function () {\r\n            return rgb2hex(this.uniforms.outlineColor);\r\n        },\r\n        set: function (value) {\r\n            hex2rgb(value, this.uniforms.outlineColor);\r\n        },\r\n        enumerable: false,\r\n        configurable: true\r\n    });\r\n    Object.defineProperty(OutlineFilter.prototype, \"thickness\", {\r\n        /**\r\n         * The thickness of the outline.\r\n         * @default 1\r\n         */\r\n        get: function () {\r\n            return this._thickness;\r\n        },\r\n        set: function (value) {\r\n            this._thickness = value;\r\n            this.padding = value;\r\n        },\r\n        enumerable: false,\r\n        configurable: true\r\n    });\r\n    /** The minimum number of samples for rendering outline. */\r\n    OutlineFilter.MIN_SAMPLES = 1;\r\n    /** The maximum number of samples for rendering outline. */\r\n    OutlineFilter.MAX_SAMPLES = 100;\r\n    return OutlineFilter;\r\n}(Filter));\r\n\r\n\r\n//# sourceMappingURL=filter-outline.esm.mjs.map\r\n\n\n//# sourceURL=webpack://sv-editor2/./modules/OutlineFilter.mjs?");

/***/ }),

/***/ "./modules/PFunc.mjs":
/*!***************************!*\
  !*** ./modules/PFunc.mjs ***!
  \***************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"Function\": () => (/* reexport safe */ _Function_mjs__WEBPACK_IMPORTED_MODULE_0__.Function),\n/* harmony export */   \"PFunc\": () => (/* binding */ PFunc),\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony import */ var _Function_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Function.mjs */ \"./modules/Function.mjs\");\n/* harmony import */ var _PIXIRendering_mjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./PIXIRendering.mjs */ \"./modules/PIXIRendering.mjs\");\n/* harmony import */ var _SvBlock_mjs__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./SvBlock.mjs */ \"./modules/SvBlock.mjs\");\n\r\n\r\n\r\n\r\nclass PFuncEditor {\r\n  constructor(linked, renderedSvBlock, projectEditor){\r\n    this.linked = linked;\r\n    this.renderedSvBlock = renderedSvBlock;\r\n    this.projectEditor = projectEditor;\r\n    this.snapToNearestLine = true;\r\n\r\n    this.htmlElement = document.createElement(\"div\");\r\n    this.htmlElement.style = `position: absolute; background: #f3f3ed80`;\r\n    const buttonMove = this.descriptionHTMLElement = document.createElement(\"button\");\r\n    this.x = 0;\r\n    this.y = 0;\r\n    buttonMove.innerText = this.linked.getLabel();\r\n    buttonMove.addEventListener('mousedown', e => {\r\n      let {screenX, screenY} = e;\r\n      document.body.addEventListener('mouseup', e => {\r\n        this.setPosition(this.x + e.screenX - screenX, this.y + e.screenY - screenY);\r\n      }, {once: true});\r\n    });\r\n    const buttonClose = document.createElement(\"button\");\r\n    buttonClose.innerText = 'x';\r\n    buttonClose.style.background = 'red';\r\n    buttonClose.addEventListener('click', () => {\r\n      this.linked.closeEditor();\r\n    }, {once: true});\r\n\r\n    const [config, operation, functionFamily] = [...new Array(3)].map(() => document.createElement('div'));\r\n\r\n    const operationInput = document.createElement('select');\r\n    Object.entries(_SvBlock_mjs__WEBPACK_IMPORTED_MODULE_2__.SvBlock.Operation).forEach(([operationName, operation]) => {\r\n      const option = document.createElement('option'); // TODO: move PFuncEditor into SvBlockEditor or some mix, this feels a bit too scuffed\r\n      option.selected = operation === renderedSvBlock.linked.operation;\r\n      option.innerText = operationName.toLowerCase();\r\n      option.value = operationName;\r\n      operationInput.append(option);\r\n    });\r\n    operationInput.addEventListener('change', () => {\r\n      renderedSvBlock.linked.operation = _SvBlock_mjs__WEBPACK_IMPORTED_MODULE_2__.SvBlock.Operation[operationInput.value];\r\n      this.refresh();\r\n    });\r\n\r\n    const [operationLabel, functionFamilyLabel] = [...new Array(2)].map(() => document.createElement('span'));\r\n    operationLabel.innerText = \"Operation\";\r\n    functionFamilyLabel.innerText = \"Function\";\r\n\r\n    operation.append(operationLabel, operationInput);\r\n    const functionFamilyInput = document.createElement('select');\r\n    Object.entries(_Function_mjs__WEBPACK_IMPORTED_MODULE_0__.Functions).forEach(([functionName, func]) => {\r\n      const option = document.createElement('option');\r\n      option.selected = func === this.linked.function;\r\n      option.innerText = functionName;\r\n      option.value = functionName;\r\n      functionFamilyInput.append(option);\r\n    });\r\n    functionFamilyInput.addEventListener('change', () => {\r\n      this.linked.function = _Function_mjs__WEBPACK_IMPORTED_MODULE_0__.Functions[functionFamilyInput.value];\r\n      this.linked.params = Object.assign(this.linked.function.generateParameters(), this.linked.params);\r\n      this.updateSliders(sliders);\r\n    });\r\n    functionFamily.append(functionFamilyLabel, functionFamilyInput);\r\n    config.append(operation, functionFamily);\r\n\r\n    const sliders = document.createElement('div');\r\n    this.updateSliders(sliders);\r\n\r\n    this.htmlElement.append(buttonMove, buttonClose, config, sliders);\r\n    this.htmlElement.addEventListener('contextmenu', event => event.preventDefault());\r\n    \r\n    document.body.append(this.htmlElement);\r\n  }\r\n  destroy(){\r\n    // this.app.destroy(true);\r\n    this.htmlElement.remove();\r\n  }\r\n  updateSliders(slidersDiv){\r\n    slidersDiv.replaceChildren();\r\n    this.linked.function.parameterNames.forEach((name, i) => {\r\n      const div = document.createElement('div');\r\n      div.classList.add('parameter');\r\n      const label = document.createElement('span');\r\n      label.classList.add('parameter_name');\r\n      label.innerText = name;\r\n      const [slider, textarea] = [... new Array(2)].map(() => document.createElement('input'));\r\n      slider.classList.add('parameter_range');\r\n      slider.type = \"range\";\r\n      slider.min = \"-4\";\r\n      slider.max = \"4\";\r\n      slider.step = \"0.01\";\r\n      slider.value = textarea.value = this.linked.params[i];\r\n      slider.addEventListener('input', () => {\r\n        this.linked.params[i] = textarea.value = slider.valueAsNumber;\r\n        this.refresh();\r\n      });\r\n      textarea.classList.add('parameter_field');\r\n      textarea.addEventListener('change', () => {\r\n        if(isNaN(+textarea.value)) textarea.value = slider.value;\r\n      })\r\n      textarea.addEventListener('input', () => {\r\n        if(!isNaN(+textarea.value)){\r\n          this.linked.params[i] = slider.value = +textarea.value;\r\n          this.refresh();\r\n        }\r\n      })\r\n      div.append(label, slider, textarea);\r\n      slidersDiv.append(div);\r\n    });\r\n    this.refresh();\r\n  }\r\n  refresh(){\r\n    this.descriptionHTMLElement.innerText = this.linked.getLabel();\r\n    this.renderedSvBlock.render(); // TODO : setup delay to avoid consecutive rerender\r\n  }\r\n  setPosition(x, y){\r\n    this.htmlElement.style.left = (this.x = x) + \"px\";\r\n    this.htmlElement.style.top = (this.y = y) + \"px\";\r\n  }\r\n}\r\n\r\n// piecewise function (desmos would be pretty cool except i have some weird operations that not sure if i can define well)\r\nclass PFunc {\r\n  constructor(parent){\r\n    this.function = _Function_mjs__WEBPACK_IMPORTED_MODULE_0__.Function.Constant;\r\n    this.params = this.function.generateParameters();\r\n    this.editor = null;\r\n    this.linked = parent;\r\n  }\r\n  isConstant(){\r\n    return this.function.isConstant();\r\n  }\r\n  getLabel(){\r\n    return this.function.getLabel(this.params);\r\n  }\r\n  integrate(a, b){\r\n    // do desmos stuff here maybe\r\n    let sum = 0;\r\n    for(let t = a; t < b; t ++) sum += Math.min(evaluate(t), 1e6*1e4);\r\n    return sum;\r\n  }\r\n  evaluate(t){\r\n    return this.function.evaluate(t, ...this.params);\r\n  }\r\n  *range(start=0, end=this.linked.duration){\r\n    throw 'not implemented';\r\n    let i = 0;\r\n    let t = start;\r\n    while(t < end){\r\n      while(this.nodes[i+1] && this.nodes[i+1].t <= t) i ++;\r\n      yield [t, this.nodes[i].easing.func(this.nodes[i].x, this.nodes[i+1]?.x, (t-this.nodes[i].t)/(this.nodes[i+1]?.t-this.nodes[i].t)), (this.nodes[i+1]?.t||this.linked.duration) - this.nodes[i].t];\r\n      t++; // i cant believe i forgot this line the first time and didnt notice it... smh infinite generator loop\r\n    }\r\n  }\r\n  openEditor(renderedSvBlock, baseEditor){ // why look for a framework or library when you can do it yourself ... it's a cool exercise tho\r\n    // throw 'not implemented';\r\n    if(this.editor) throw 'pfunc editor already opened';\r\n    this.editor = new PFuncEditor(this, renderedSvBlock, baseEditor);\r\n    /*if(baseEditor){\r\n      this.editor.setTime(baseEditor.t);\r\n      this.editor.setTimeScale(baseEditor.z);\r\n    }*/\r\n  }\r\n  closeEditor(){\r\n    this.editor?.destroy();\r\n    this.editor = null;\r\n  }\r\n  set(args){\r\n    for(const k in this.params) this.params[k] = args[k] || 0;\r\n  }\r\n  update(args){\r\n    for(const k in this.params) this.params[k] = k in args ? args[k] : this.params[k];\r\n  }\r\n  toLatex(){\r\n    throw 'not implemented';\r\n    // for desmos calculations ~~cuz numerical piecewise is terrible for performance~~ (or maybe misusing yield?, yes turned out to be misuing yield)\r\n    // f\\left(x\\right)=\\left\\{0<x<1:4,1<x<2:3\\right\\}\r\n    let piecewise = \"\";\r\n    for(let i = 0; i < this.nodes.length; i ++){\r\n      const node = this.nodes[i];\r\n      const end = this.nodes[i+1]?.t||this.linked.duration;\r\n      piecewise += `${(node.t/1000).toFixed(3)}<x\\\\le${(end/1000).toFixed(3)}:${Math.min(30, node.x).toFixed(2)},`;\r\n    }\r\n    return `f\\\\left(x\\\\right)=\\\\left\\\\{${piecewise.replace(/,$/, '')}\\\\right\\\\}`;\r\n  }\r\n}\r\n\r\n\r\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (PFunc);\r\n\n\n//# sourceURL=webpack://sv-editor2/./modules/PFunc.mjs?");

/***/ }),

/***/ "./modules/PIXIRenderedSprites.mjs":
/*!*****************************************!*\
  !*** ./modules/PIXIRenderedSprites.mjs ***!
  \*****************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"SpriteRenderer\": () => (/* binding */ SpriteRenderer),\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n\r\nclass SpriteRenderer {\r\n  constructor(app){\r\n    const g = new PIXI.Graphics();\r\n    g.beginFill(0x0077e6);\r\n    g.drawRect(0, 0, 100, 40);\r\n    g.endFill();\r\n\r\n    this.Note = app.renderer.generateTexture(g);\r\n\r\n    g.clear();\r\n    g.beginFill(0x00e699);\r\n    g.drawRect(0, 0, 100, 40);\r\n    g.endFill();\r\n    this.LongNoteHead = app.renderer.generateTexture(g);\r\n\r\n    g.clear();\r\n    g.beginFill(0x00b87a);\r\n    g.drawRect(0, 0, 100, 40);\r\n    g.endFill();\r\n    this.LongNoteTail = app.renderer.generateTexture(g);\r\n\r\n    g.clear();\r\n    g.beginFill(0x00b87a);\r\n    g.drawRect(15, 0, 70, 1);\r\n    g.endFill();\r\n    this.LongNoteBody = app.renderer.generateTexture(g);\r\n  }\r\n}\r\n\r\n\r\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (SpriteRenderer);\r\n\n\n//# sourceURL=webpack://sv-editor2/./modules/PIXIRenderedSprites.mjs?");

/***/ }),

/***/ "./modules/PIXIRendering.mjs":
/*!***********************************!*\
  !*** ./modules/PIXIRendering.mjs ***!
  \***********************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"Line\": () => (/* binding */ RenderedLine),\n/* harmony export */   \"LongNote\": () => (/* binding */ RenderedLongNote),\n/* harmony export */   \"Note\": () => (/* binding */ RenderedNote),\n/* harmony export */   \"RenderedObject\": () => (/* binding */ RenderedObject),\n/* harmony export */   \"SvBlock\": () => (/* binding */ RenderedSvBlock),\n/* harmony export */   \"from\": () => (/* binding */ from)\n/* harmony export */ });\n/* harmony import */ var _Notes_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Notes.mjs */ \"./modules/Notes.mjs\");\n/* harmony import */ var _SvBlock_mjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./SvBlock.mjs */ \"./modules/SvBlock.mjs\");\n/* harmony import */ var _OutlineFilter_mjs__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./OutlineFilter.mjs */ \"./modules/OutlineFilter.mjs\");\n/* harmony import */ var _Constants_mjs__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./Constants.mjs */ \"./modules/Constants.mjs\");\n\r\n\r\n\r\n\r\n\r\n\r\n\r\nclass RenderedObject {\r\n  constructor(linked={}){\r\n    this.linked = linked; // TODO: disconnect RenderedObject from Object? (other way might make more sense)\r\n\r\n    this.selected = false;\r\n    this.graphics = null;\r\n    // this.z = 1;\r\n  }\r\n  getStart(){\r\n    return this.linked.getStart();\r\n  }\r\n  getEnd(){\r\n    return this.linked.getEnd();\r\n  }\r\n  setTimeScale(timeScale){\r\n    // this.z = timeScale;\r\n    return this.graphics.position.y = ~~(-this.getStart() * timeScale);\r\n  }\r\n  select(){\r\n    this.selected = true;\r\n    if(this.graphics){\r\n      this.graphics.tint = 0xAADDDD;\r\n      this.graphics.filters = [new _OutlineFilter_mjs__WEBPACK_IMPORTED_MODULE_2__.OutlineFilter(1, 0xd69600)];\r\n    }\r\n    return this;\r\n  }\r\n  deselect(){\r\n    this.selected = false;\r\n    if(this.graphics){\r\n      this.graphics.tint = 0xFFFFFF;\r\n      this.graphics.filters = [];\r\n    }\r\n    return this;\r\n  }\r\n  destroy(){\r\n    this.graphics.parent.removeChild(this.graphics);\r\n  }\r\n}\r\n\r\nconst measurelines = [null, [1]]\r\nfunction measureline(x){\r\n  if(x in measurelines) return measurelines[x];\r\n  for(let d = 2; d <= x; d ++){\r\n    if(x/d%1 === 0){\r\n      let z = measureline(x/d).slice(0);\r\n      if(!(x in measurelines)) measurelines[x] = z;\r\n      for(let i = z.length; i > 0; i --) z.splice(i, 0, ...[...new Array(d-1)].map(() => x));\r\n      return z;\r\n    }\r\n  }\r\n} // scuffed procedural way to generate them\r\nfor(let i = 1; i < 100; i++) measureline(i);\r\n// console.log(measurelines);\r\n\r\nclass RenderedLine extends RenderedObject {\r\n  static colorSchemes = measurelines;\r\n  static colors = [null, 0x000000, 0xf26250, 0xb74fa9, 0x37aedc, 0x686868, 0xf8d44f, 0xf8d44f, 0xf8d44f];\r\n  constructor(){\r\n    super();\r\n    this.linked = null;\r\n    this.type = 1;\r\n    this.t = 0;\r\n    const g = this.graphics = new PIXI.Graphics();\r\n    g.beginFill(0x000000);\r\n    g.drawRect(0, 0, 400, 1);\r\n    g.endFill();\r\n  }\r\n  setType(i){\r\n    if(this.type === i) return;\r\n    this.type = i;\r\n    const g = this.graphics;\r\n    g.clear();\r\n    g.beginFill(RenderedLine.colors[i]);\r\n    g.drawRect(0, 0, 400, 1);\r\n    g.endFill();\r\n  }\r\n  setTimeScale(timeScale){\r\n    // this.z = timeScale;\r\n    return this.graphics.position.y = ~~(-this.t * timeScale);\r\n  }\r\n  setPosition(t, z){\r\n    this.t = ~~t;\r\n    return this.setTimeScale(z);\r\n  }\r\n  static calculatePosition(t, z){\r\n    return (~~t)*z;\r\n  }\r\n}\r\n\r\nclass RenderedNote extends RenderedObject {\r\n  constructor(linked, editor){\r\n    super(linked);\r\n    let g;\r\n    if(editor){\r\n      g = this.graphics = new PIXI.Sprite(editor.sprites.Note);\r\n    }else{\r\n      g = this.graphics = new PIXI.Graphics();\r\n      g.beginFill(0x0077e6);\r\n      g.drawRect(0, 0, 100, 40);\r\n    }\r\n    g.pivot.set(0, g.height); // nudge up\r\n    g.position.set(this.linked.x*100, -this.linked.t);\r\n  }\r\n  setTime(t){ // method for live replay\r\n    // this.graphics.position.y = -(this.t = t);\r\n    this.linked.setTime(t);\r\n  }\r\n}\r\n\r\nclass RenderedLongNote extends RenderedObject {\r\n  constructor(linked, editor){\r\n    super(linked);\r\n    const g = this.graphics = new PIXI.Container();\r\n    let head, tail, body;\r\n    if(editor){\r\n      head = new PIXI.Sprite(editor.sprites.LongNoteHead);\r\n      tail = new PIXI.Sprite(editor.sprites.LongNoteTail);\r\n      body = new PIXI.Sprite(editor.sprites.LongNoteBody);\r\n    }else{\r\n      head = new PIXI.Graphics();\r\n      head.beginFill(0x00e699);\r\n      head.drawRect(0, 0, 100, 40);\r\n      tail = this.graphicsTail = new PIXI.Graphics();\r\n      tail.beginFill(0x00b87a);\r\n      tail.drawRect(0, 0, 100, 40);\r\n      body = this.graphicsBody = new PIXI.Graphics();\r\n      body.beginFill(0x00b87a);\r\n      body.drawRect(15, 0, 70, 1);\r\n    }\r\n\r\n    // tail.position.y = -(this.t$ - this.t);\r\n    // body.scale.y = tail.position.y - head.height - tail.height;\r\n\r\n    g.addChild(body, head, tail);\r\n    g.pivot.set(0, head.height); // nudge up so (0,0) is the visually the very bottom\r\n    g.position.set(this.linked.x*100, -this.linked.t);\r\n  }\r\n  setTime(start, end){\r\n    this.linked.setTime(start, end);\r\n  }\r\n  setTimeScale(timeScale){\r\n    // this.z = timeScale;\r\n    this.graphics.position.y = ~~(-this.linked.t * timeScale);\r\n    this.graphicsTail.position.y = ~~(-(this.linked.t$ - this.linked.t) * timeScale);\r\n    this.graphicsBody.scale.y = ~~(-(Math.abs(this.graphicsTail.position.y) - this.graphicsTail.height));\r\n  }\r\n}\r\n\r\nclass RenderedSvBlock extends RenderedObject {\r\n  constructor(linked, baseEditor){\r\n    super(linked);\r\n    const g = this.graphics = new PIXI.Container();\r\n    // g.filters = [new OutlineFilter(1, 0xd69600)]; // TODO: don't use a filter and just redraw the rect\r\n    const body = this.graphicsBody = new PIXI.Graphics();\r\n    body.beginFill(0xffba1a); // hsl(42, 100%, 55%)\r\n    // body.lineStyle(1, 0xd69600); // hsl(42, 100%, 42%)\r\n    body.drawRect(0, 0, 25, 1);\r\n    body.beginFill(0xefaa0a);\r\n    body.drawRect(25, 0, 25, 1);\r\n    body.alpha = 0.5; // to check for overlap\r\n    if(baseEditor){\r\n      g.pivot.x = -baseEditor.bounds.blockLeft;\r\n    }\r\n    /*this.graphicsDebugDisplay = new PIXI.Text(\"\", {\r\n      fontName: \"Arial\",\r\n      fontSize: 12,\r\n      align: \"center\"\r\n    });*/\r\n    const tx = this.graphicsLabel = new PIXI.Text(linked.getLabel(), { // TODO: maybe use bitmaptext later\r\n      fontName: \"Arial\",\r\n      fontSize: 12,\r\n      align: \"left\"\r\n    }); // TODO: render other types of sv block\r\n    tx.position.y = -tx.height;\r\n    const line = this.graphicsLine = new PIXI.Graphics();\r\n    this.render();\r\n    body.addChild(line);\r\n    g.addChild(body, tx); //, this.graphicsDebugDisplay\r\n    body.interactive = true;\r\n    body.on('pointerover', () => {\r\n      body.alpha = 1;\r\n      if(baseEditor && !baseEditor.mouseOver) baseEditor.mouseOver = this;\r\n    });\r\n    body.on('pointerout', () => {\r\n      body.alpha = 0.5;\r\n      if(baseEditor?.mouseOver == this) baseEditor.mouseOver = null;\r\n    });\r\n    body.on('pointerdown', e => {\r\n      console.log(\"[svblock] tap!\", e.data.button, e.data.buttons);\r\n      switch(e.data.button){\r\n        case _Constants_mjs__WEBPACK_IMPORTED_MODULE_3__.MouseButtons.LEFT:\r\n          baseEditor.initiateMouseAction(baseEditor.constructor.Actions.MoveSelection);\r\n          break;\r\n        case _Constants_mjs__WEBPACK_IMPORTED_MODULE_3__.MouseButtons.MIDDLE:\r\n          this.destroy(baseEditor);\r\n          break;\r\n        case _Constants_mjs__WEBPACK_IMPORTED_MODULE_3__.MouseButtons.RIGHT:\r\n          if(!this.linked.func.editor){\r\n            this.linked.func.openEditor(this, baseEditor);\r\n            this.linked.func.editor.setPosition(e.data.global.x, e.data.global.y);\r\n          }else{\r\n            this.linked.func.closeEditor();\r\n          }\r\n      }\r\n    });\r\n  }\r\n  render(){ // the thing shown on the rectangle for the svBlock\r\n    this.graphicsLabel.text = this.linked.getLabel();\r\n    return; // TODO: implement render\r\n    const l = this.graphicsLine;\r\n    l.clear();\r\n    let x;\r\n    let y; // should be (t=0)\r\n    l.lineStyle(1, 0x000000);\r\n    l.moveTo(x=RenderedSvBlock.mapXToHorizontalPosition(this.linked.func.nodes[0].x), y=0);\r\n    for(let node of this.linked.func.nodes){\r\n      // if(-y > 1000) l.lineStyle(1, 0x000000);\r\n      l.lineTo(x, y=RenderedSvBlock.mapTToVerticalPosition(node.t));\r\n      l.lineTo(x=RenderedSvBlock.mapXToHorizontalPosition(node.x), y);\r\n      // console.log(x, y);\r\n    }\r\n    l.lineTo(x, y=RenderedSvBlock.mapTToVerticalPosition(this.linked.duration));\r\n    // console.log(x, y);\r\n    this.graphicsLine.scale.y = 1/y;\r\n  }\r\n  static mapXToHorizontalPosition(x){\r\n    return ~~(Math.min(Math.max(x*20, 0), 40)+5);\r\n  }\r\n  static mapTToVerticalPosition(t){\r\n    return ~~(-t/4);\r\n  }\r\n  setTime(start, end){\r\n    this.linked.setTime(start, end);\r\n  }\r\n  setTimeScale(timeScale){\r\n    this.graphics.position.x = this.linked.x * 50; // TODO : dont hardcode width\r\n    this.graphics.position.y = -this.linked.t * timeScale;\r\n    this.graphicsBody.scale.y = -this.linked.duration * timeScale;\r\n  }\r\n  getX(){\r\n    return this.linked.getX();\r\n  }\r\n  setX(x){\r\n    this.linked.setX(x);\r\n  }\r\n  destroy(baseEditor){\r\n    RenderedObject.prototype.destroy.call(this);\r\n    if(baseEditor?.mouseOver == this) baseEditor.mouseOver = null;\r\n    if(baseEditor) baseEditor.removeBlock(this);\r\n  }\r\n}\r\n\r\n/* class RenderedSvColumn extends RenderedObject { // more like a container\r\n  constructor(linked){\r\n    super(linked);\r\n    const g = this.graphics = new PIXI.Container();\r\n    this.blocks = [];\r\n    linked.blocks.forEach(block => {\r\n      const b = new RenderedSvBlock(block);\r\n      this.blocks.push(b);\r\n      g.addChild(b.graphics);\r\n    })\r\n  }\r\n  addBlock(svBlock){\r\n    const b = new RenderedSvBlock(svBlock);\r\n    this.blocks.push(b);\r\n    g.addChild(b.graphics);\r\n  }\r\n  setTimeScale(timeScale){\r\n    this.blocks.forEach(block => block.setTimeScale(timeScale));\r\n  }\r\n} */\r\n\r\nfunction from(obj, baseEditor){\r\n  if(obj instanceof _Notes_mjs__WEBPACK_IMPORTED_MODULE_0__.LongNote) return new RenderedLongNote(obj, baseEditor);\r\n  else if(obj instanceof _Notes_mjs__WEBPACK_IMPORTED_MODULE_0__.Note) return new RenderedNote(obj, baseEditor);\r\n  else if(obj instanceof _Notes_mjs__WEBPACK_IMPORTED_MODULE_0__.SvBlock) return new RenderedSvBlock(obj, baseEditor);\r\n  else return null;\r\n}\r\n\r\n\r\n\n\n//# sourceURL=webpack://sv-editor2/./modules/PIXIRendering.mjs?");

/***/ }),

/***/ "./modules/Project.mjs":
/*!*****************************!*\
  !*** ./modules/Project.mjs ***!
  \*****************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"Project\": () => (/* binding */ Project),\n/* harmony export */   \"ProjectEditor\": () => (/* binding */ ProjectEditor),\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__),\n/* harmony export */   \"sortByTime\": () => (/* binding */ sortByTime)\n/* harmony export */ });\n/* harmony import */ var _Notes_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Notes.mjs */ \"./modules/Notes.mjs\");\n/* harmony import */ var _Constants_mjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./Constants.mjs */ \"./modules/Constants.mjs\");\n/* harmony import */ var _PIXIRendering_mjs__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./PIXIRendering.mjs */ \"./modules/PIXIRendering.mjs\");\n/* harmony import */ var _PIXIRenderedSprites_mjs__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./PIXIRenderedSprites.mjs */ \"./modules/PIXIRenderedSprites.mjs\");\n/* harmony import */ var _SvBlock_mjs__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./SvBlock.mjs */ \"./modules/SvBlock.mjs\");\n/* harmony import */ var _pixi_essentials_cull__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! @pixi-essentials/cull */ \"./node_modules/@pixi-essentials/cull/lib/cull.es.js\");\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\nconst Actions = Object.freeze({\r\n  PlaceSVBlock: Symbol(\"place sv block\"),\r\n  MoveSelection: Symbol(\"move selected items\"),\r\n});\r\n\r\n// console.log(Rendered);\r\n\r\nclass ProjectEditor {\r\n  static Actions = Actions;\r\n  constructor(linked){\r\n    this.bounds = {\r\n      noteLeft: 0,\r\n      noteRight: 400,\r\n      blockLeft: 400,\r\n      blockRight: 650,\r\n      resultLeft: 650,\r\n      resultRight: 750,\r\n      liveLeft: 750,\r\n      liveRight: 1150\r\n    };\r\n\r\n    this.linked = linked;\r\n    this.htmlElement = document.createElement(\"div\");\r\n    this.htmlElement.style = `position: absolute;\r\noverflow:hidden;\r\nwidth:100vw;\r\nheight:100vh;`;\r\n    const app = this.app = new PIXI.Application({\r\n        resizeTo: window,\r\n        antialias: true,\r\n        transparent: true,\r\n        resolution: 1\r\n      }\r\n    );\r\n    // const cull = new Cull({ recursive: true, toggle: 'renderable' });\r\n    // cull.add(app.stage);\r\n    // app.renderer.on('prerender', () => cull.cull(app.renderer.screen));\r\n\r\n    this.sprites = new _PIXIRenderedSprites_mjs__WEBPACK_IMPORTED_MODULE_3__[\"default\"](app);\r\n    const dynamic = this.dynamicStage = new PIXI.Container(); // editor side\r\n    const projected = this.projectedStage = new PIXI.Container(); // result side\r\n    this.t = 0;\r\n    this.mouseX = this.mouseY = this.mouseT = 0;\r\n    this.mouseOver = null;\r\n    this.mouseAction = null;\r\n    this.prevSnap = 0; // if we're gonna be rendering measurelines might as well use them :D\r\n    this.nextSnap = 0;\r\n    this.prevMeasure = 0;\r\n    this.nextMeasure = 0;\r\n    this.z = 0.01;\r\n    this.subdivisions = 4;\r\n    app.view.addEventListener('contextmenu', event => event.preventDefault());\r\n    app.view.addEventListener('mousemove', e => {\r\n      [this.mouseX, this.mouseY] = [e.offsetX, e.offsetY];\r\n      this.refreshMousePosition();\r\n      /*if(this.mouseOver) this.mouseOver.graphics.tint = 0xFFFFFF;\r\n      if(e.offsetX < 400){\r\n        let mouseCol = Math.floor(e.offsetX/400*this.linked.metadata.Difficulty.CircleSize);\r\n        console.log(mouseCol, t);\r\n        for(let note of this.notes){\r\n          let bottomT = note.linked.t;\r\n          let topT = note.linked.getEnd() + 40/this.z;\r\n          if(mouseCol === note.linked.x && t > bottomT && t < topT){\r\n            this.mouseOver = note;\r\n            break;\r\n          }\r\n        }\r\n      }else{\r\n\r\n      }\r\n      if(this.mouseOver) this.mouseOver.graphics.tint = 0x555555;*/\r\n    });\r\n    app.view.addEventListener('pointerdown', e => { // fix eventlisteners\r\n      // console.log(\"pointerdown\", e.offsetX, e.offsetY);\r\n      if(this.mouseOver){\r\n\r\n      }else{\r\n        if(e.offsetX < this.bounds.noteRight){ // notes\r\n\r\n        }else if(e.offsetX < this.bounds.blockRight){ // sv columns\r\n          if(e.button === _Constants_mjs__WEBPACK_IMPORTED_MODULE_1__.MouseButtons.LEFT) this.initiateMouseAction(Actions.PlaceSVBlock);\r\n        }\r\n      }\r\n    });\r\n    app.view.addEventListener('pointerup', e => {\r\n      // console.log(\"pointerup\", e.offsetX, e.offsetY, this.mouseAction)\r\n      if(this.mouseOver && !this.mouseAction){\r\n\r\n      }else{\r\n        // if(e.offsetX < this.bounds.noteRight){ // notes\r\n        // }else if(e.offsetX < this.bounds.blockRight){ // sv columns\r\n        // }\r\n        this.resolveMouseAction();\r\n      }\r\n    });\r\n    app.view.addEventListener('wheel', e => {\r\n      if(e.deltaY === 0) return; // displacement\r\n      let up = e.deltaY < 0;\r\n      if(e.ctrlKey){\r\n        this.setTimeScale(this.z = up ? (this.z*2) : (this.z/2));\r\n      }else{\r\n        // if lines arent rendered completely cuz its zoomed out too much just use 1 second default (no ternary cuz thats unreadable)\r\n        if(this.lines[this.lines.length-1].t < this.t){\r\n          this.setTime(Math.max(0, this.t + (up ? -1 : 1)*1000*(e.shiftKey ? 10 : 1)));\r\n        }else{\r\n          if(e.altKey){\r\n            this.setTime(this.t + (up ? -1 : 1));\r\n          } else this.setTime(Math.max(0, this[(!up?\"next\":\"prev\")+(!e.shiftKey?\"Snap\":\"Measure\")]));\r\n        }\r\n      }\r\n      e.preventDefault();\r\n    });\r\n\r\n    // app.view.addEventListener('keydown', e => { // keydown only fires on contenteditable stuff\r\n    document.body.addEventListener('keydown', e => {\r\n      if(e.keyCode>=32) console.log(e.keyCode);\r\n      this.songAudio = this.linked.songAudio;\r\n      switch(e.keyCode){\r\n        case 32: // space\r\n          if(this.songAudio.playing()){\r\n            this.songAudio.pause();\r\n            app.ticker.remove(this.syncTimeToAudio, this);\r\n          }else{\r\n            this.songAudio.seek(this.t/1000);\r\n            this.songAudio.play();\r\n            app.ticker.add(this.syncTimeToAudio, this);\r\n          }\r\n          break;\r\n      }\r\n    });\r\n\r\n    this.lines = [...new Array(50)].map(x => {\r\n      const line = new _PIXIRendering_mjs__WEBPACK_IMPORTED_MODULE_2__.Line();\r\n      dynamic.addChild(line.graphics);\r\n      return line;\r\n    });\r\n\r\n    this.notes = [];\r\n    linked.notes.forEach(this.addNote.bind(this));\r\n\r\n    this.blocks = [];\r\n    linked.blocks.forEach(this.addBlock.bind(this));\r\n\r\n    let line = new _PIXIRendering_mjs__WEBPACK_IMPORTED_MODULE_2__.Line().graphics;\r\n    line.position.y = 1;\r\n    line.scale.x = (this.bounds.resultRight - this.bounds.noteLeft) / line.width;\r\n    line.scale.y = 3;\r\n    line.alpha = 0.8;\r\n    let line2 = new _PIXIRendering_mjs__WEBPACK_IMPORTED_MODULE_2__.Line().graphics;\r\n    line2.position.set(this.bounds.liveLeft, 1);\r\n    line2.scale.x = (this.bounds.liveRight - this.bounds.liveLeft) / line2.width;\r\n    line2.scale.y = 3;\r\n    line2.alpha = 1;\r\n\r\n    projected.position.x = this.bounds.resultRight;\r\n    projected.scale.x = 0.5;\r\n\r\n    const result = this.resultGraphics = new PIXI.Graphics();\r\n    result.position.set(this.bounds.resultLeft, 1);\r\n    dynamic.addChild(result);\r\n\r\n    this.refreshOutput();\r\n\r\n    this.setTime();\r\n    app.stage.addChild(dynamic, projected, line, line2);\r\n    this.htmlElement.append(app.view);\r\n    document.body.append(this.htmlElement);\r\n\r\n    this.setTimeScale(0.32); // syncs everything\r\n  }\r\n  setTime(time){\r\n    if(time !== undefined) this.t = time;\r\n    this.app.stage.pivot.y = -(this.app.view.height-100);\r\n    // this.dynamicStage.pivot.y = 40; // nudge up everything\r\n    this.dynamicStage.position.y = this.t*this.z;\r\n    this.projectedStage.position.y = this.displacement[~~this.t];\r\n\r\n    let i = 0;\r\n    let currentTimingPoint = this.linked.timingPoints[0]; // TODO: use something O(1) instead of O(n)\r\n    while(i < this.linked.timingPoints.length){\r\n      const timingPoint = this.linked.timingPoints[i];\r\n      if(timingPoint.t > this.t) break;\r\n      currentTimingPoint = timingPoint;\r\n      i ++;\r\n    }\r\n    let t = this.t - 100/this.z;  // should be very bottom, y=zt; t=y/z\r\n    // let prevTime = 0; // TODO: avoid rendering if they're too close\r\n    // let prevY = 0;\r\n    let mspb = 60000 / currentTimingPoint.bpm;\r\n    t = Math.floor(t / mspb -1) * mspb + (currentTimingPoint.t)%mspb;\r\n    let k = 0;\r\n    let jStart = 0;\r\n    this.nextSnap = this.nextMeasure = 0;\r\n    this.lines.forEach((line, j) => { // TODO : lines are kinda buggy on variable bpm stuff\r\n      let J = j - jStart;\r\n      let time = t + 60000 / currentTimingPoint.bpm / this.subdivisions * J;\r\n      let truncatedTime = ~~time;\r\n      while(time > this.linked.timingPoints[i+1]?.t){\r\n        i ++;\r\n        currentTimingPoint = this.linked.timingPoints[i];\r\n        time = t = currentTimingPoint.t;\r\n        truncatedTime = ~~time;\r\n        jStart = j;\r\n        J = 0;\r\n      }\r\n      line.setType(_PIXIRendering_mjs__WEBPACK_IMPORTED_MODULE_2__.Line.colorSchemes[this.subdivisions][J % this.subdivisions]);\r\n      line.setPosition(time, this.z);\r\n      if(time < this.t-1.5) this.prevSnap = truncatedTime;\r\n      if(time > this.t+1.5 && !this.nextSnap) this.nextSnap = truncatedTime;\r\n      if(J % this.subdivisions === 0){\r\n        if(time < this.t-1.5) this.prevMeasure = truncatedTime;\r\n        if(time > this.t+1.5 && !this.nextMeasure) this.nextMeasure = truncatedTime;\r\n      } // to get all measure snaps: this.lines.map(l => l.t)\r\n    });\r\n\r\n    // this.blocks.forEach(b => {\r\n    //   const block = b.linked;\r\n    //   const svBlockEditor = block.func.editor;\r\n    //   if(svBlockEditor && this.t >= block.t && this.t <= block.t+block.duration){ // filter condition\r\n    //     svBlockEditor.setTimeScale(this.z);\r\n    //     svBlockEditor.setTime(this.t-block.t);\r\n    //   }\r\n    //   /* b.graphicsDebugDisplay.text = block.func.evaluate(this.t - block.t).toFixed(3) + 'x';\r\n    //   b.graphicsDebugDisplay.position.y = -this.dynamicStage.position.y - b.graphics.position.y;\r\n    //   b.graphicsDebugDisplay.anchor.set(0, 0); */\r\n    // });\r\n\r\n    // some tree structure seems appropriate for culling (esp since they dont move around much)\r\n    if(this.renderedMinT === void 0 || (this.t < this.renderedMinT || this.t > this.renderedMaxT)) this.refreshCulling();\r\n    this.refreshMousePosition();\r\n  }\r\n  refreshMousePosition(){\r\n    const dy = this.mouseY - (this.app.view.height-100);\r\n    this.mouseT = this.t - dy/this.z;\r\n    this.mouseTAligned = this.getNearestLine(Math.floor(this.mouseT));\r\n    this.refreshMouseAction();\r\n  }\r\n  refreshCulling(){ // return;\r\n    const viewport = this.app.screen;\r\n    const minY = viewport.y - 1000;\r\n    const maxY = viewport.height + 500;\r\n    this.renderedMinT = this.t - (maxY - (this.app.view.height-100))/this.z;\r\n    this.renderedMaxT = this.t - (minY + (this.app.view.height-100))/this.z;\r\n    this.notes.forEach(n => {\r\n      const bounds = n.graphics.getBounds();\r\n      n.graphics.renderable = n.graphics.interactive = n.graphics.interactiveChildren = n.linked.projected.graphics.renderable = bounds.y+bounds.height>=minY && bounds.y-bounds.height <= maxY;\r\n    })\r\n    this.blocks.forEach(n => {\r\n      const bounds = n.graphics.getBounds();\r\n      n.graphics.renderable = n.graphics.interactive = n.graphics.interactiveChildren = bounds.y+bounds.height>=minY && bounds.y-bounds.height <= maxY;\r\n    })\r\n    this.refreshResult();\r\n  }\r\n  setTimeScale(z){\r\n    // y = zt\r\n    /*this.t += this.t * (z-this.z) / z;\r\n    this.app.stage.position.y = this.t*z;*/\r\n    this.setTime(this.t + this.t * (z-this.z) / z);\r\n    this.z = z;\r\n    this.notes.forEach(n => n.setTimeScale(z));\r\n    this.blocks.forEach(block => block.setTimeScale(z));\r\n    this.refreshCulling();\r\n  }\r\n  syncTimeToAudio(){\r\n    if(!this.songAudio) throw \"audio file not found\";\r\n    this.setTime(this.songAudio.seek()*1000);\r\n  }\r\n  getNearestLine(t){ // TODO : binary search\r\n    let newT = t;\r\n    let diff = Infinity;\r\n    for(let i = 0; i < this.lines.length; i ++){\r\n      var newDiff = Math.abs(this.lines[i].t - t);\r\n      if(newDiff <= diff){\r\n        diff = newDiff;\r\n        newT = this.lines[i].t;\r\n      } else return newT;\r\n    }\r\n    return newT;\r\n  }\r\n  addNote(note){\r\n    const n = _PIXIRendering_mjs__WEBPACK_IMPORTED_MODULE_2__.from(note);\r\n    this.dynamicStage.addChild(n.graphics);\r\n    const n2 = _PIXIRendering_mjs__WEBPACK_IMPORTED_MODULE_2__.from(note.clone());\r\n    note.projected = n2;\r\n    n2.setTimeScale(1); // TODO: uhh i'll sync this later\r\n    this.projectedStage.addChild(n2.graphics);\r\n    this.notes.push(n);\r\n    return n;\r\n  }\r\n  addBlock(block){\r\n    const b = _PIXIRendering_mjs__WEBPACK_IMPORTED_MODULE_2__.from(block, this);\r\n    // b.graphics.position.x = this.bounds.blockLeft + 50*block.x;\r\n    b.setTimeScale(this.z);\r\n    this.dynamicStage.addChild(b.graphics);\r\n    this.blocks.push(b);\r\n    return b;\r\n  }\r\n  removeNote(note){\r\n    // TODO: implement\r\n  }\r\n  removeBlock(block){ // TODO: binary search? or use map<int, Block>\r\n    // call from RenderedObject since this only updates virtual objects and not the rendered ones\r\n    let i = this.blocks.indexOf(block);\r\n    if(i >= 0){\r\n      this.blocks.splice(i, 1);\r\n      this.linked.removeBlock(block.linked);\r\n    } else console.warn(\"remove block -- block not found\", block);\r\n  }\r\n  refreshOutput(){\r\n    let _start = performance.now();\r\n    this.linked.calculateSpeedOutput(); // TODO: only update portions instead of refreshing the entire thing\r\n    this.displacement = [...new Array(this.linked.speed.length)];\r\n    for(let i in this.displacement){\r\n      this.displacement[i] = (this.displacement[i-1]||0) + Math.min(1e3, this.linked.speed[i]);\r\n    }\r\n    this.linked.notes.forEach(n => { // TODO: good question why its -1, probably some off by one error.. but fix that later\r\n      n.projected.setTime(this.displacement[n.t-1]||0, n.t$&&this.displacement[n.t$-1]||0);\r\n      n.projected.setTimeScale(1);\r\n    });\r\n    console.log(\"= total refresh time\", 0|(performance.now()-_start), \"ms\")\r\n    this.refreshResult();\r\n  }\r\n  refreshResult(){\r\n    const result = this.resultGraphics;\r\n    result.clear();\r\n    result.pivot.set(0, 0);\r\n    result.position.set(0, 0);\r\n    result.scale.set(1, 1);\r\n    result.lineStyle(2, \"0x000000\");\r\n    const buffer = Math.floor(this.renderedMaxT-this.renderedMinT);\r\n    const start = Math.max(0, Math.floor(this.renderedMinT - buffer));\r\n    const end = Math.min(this.linked.speed.length, Math.floor(this.renderedMaxT + buffer));\r\n    result.moveTo(Math.min(100, Math.max(0, this.linked.speed[start]*25)), 0);\r\n    for(let i = start; i <= end; i ++){\r\n      result.lineTo(Math.min(100, Math.max(0, this.linked.speed[i]*25)), i-start);\r\n    }\r\n    // result.pivot.set(0, result.height);\r\n    result.position.set(this.bounds.resultLeft, ~~(-start*this.z));\r\n    result.scale.set(1, -this.z);\r\n  }\r\n  initiateMouseAction(action, source=null){\r\n    this.abortMouseAction();\r\n    switch(action){\r\n      case Actions.PlaceSVBlock: {\r\n        const preview = _PIXIRendering_mjs__WEBPACK_IMPORTED_MODULE_2__.from(new _SvBlock_mjs__WEBPACK_IMPORTED_MODULE_4__.SvBlock(), this);\r\n        const x = Math.floor((this.mouseX-this.bounds.blockLeft)/((this.bounds.blockRight-this.bounds.blockLeft)/5));\r\n        // preview.graphics.position.x = this.bounds.blockLeft + 50*x;\r\n        preview.setX(x);\r\n        preview.graphics.interactive = preview.graphics.interactiveChildren = false;\r\n        preview.graphicsBody.tint = 0xaaccee;\r\n        this.dynamicStage.addChild(preview.graphics);\r\n        this.mouseAction = {\r\n          type: action,\r\n          x: x,\r\n          t: this.mouseTAligned,\r\n          preview: preview,\r\n        };\r\n        this.refreshMouseAction();\r\n        break;\r\n      }\r\n      case Actions.MoveSelection: {\r\n        const sources = [source || this.mouseOver];\r\n        this.mouseAction = {\r\n          type: action,\r\n          mouseX: this.mouseX,\r\n          mouseT: this.mouseTAligned,\r\n          sources: sources,\r\n          previews: sources.map(source => {\r\n            const preview = _PIXIRendering_mjs__WEBPACK_IMPORTED_MODULE_2__.from(source.linked.clone(), this);\r\n            preview.graphics.interactive = preview.graphics.interactiveChildren = false;\r\n            preview.graphicsBody.tint = 0xff0000;\r\n            this.dynamicStage.addChild(preview.graphics);\r\n            return preview;\r\n          }),\r\n        };\r\n        this.refreshMouseAction();\r\n        break;\r\n      }\r\n    }\r\n  }\r\n  refreshMouseAction(){\r\n    if(!this.mouseAction) return;\r\n    switch(this.mouseAction.type){\r\n      case Actions.PlaceSVBlock:\r\n        if(this.mouseOver){\r\n          // console.log(this.mouseOver.linked.x, this.mouseAction.x);\r\n          if(this.mouseOver.linked.x === this.mouseAction.x) this.mouseTAligned = Math.max(this.mouseAction.t, this.mouseTAligned) >= this.mouseOver.getEnd() ? this.mouseOver.getEnd() : this.mouseOver.getStart(); // same column, so snap to closer to first\r\n          else this.mouseTAligned = this.mouseT > (this.mouseOver.getStart()+this.mouseOver.getEnd())/2 ? this.mouseOver.getEnd() : this.mouseOver.getStart(); // diff column so snap to nearer side\r\n        }\r\n        this.mouseAction.preview.setTime(Math.min(this.mouseAction.t, this.mouseTAligned), Math.max(this.mouseAction.t, this.mouseTAligned));\r\n        this.mouseAction.preview.setTimeScale(this.z);\r\n        // console.log(this.mouseAction.preview);\r\n        // console.log(this.mouseAction.t, this.mouseTAligned, this.mouseAction);\r\n        break;\r\n      case Actions.MoveSelection: {\r\n        const {dx, dt} = this.mouseAction;\r\n        this.mouseAction.dx = Math.round((this.mouseX - this.mouseAction.mouseX)/50);\r\n        this.mouseAction.dt = this.mouseTAligned - this.mouseAction.mouseT;\r\n        if(dx !== this.mouseAction.dx || dt !== this.mouseAction.dt){\r\n          for(let i = 0; i < this.mouseAction.sources.length; i ++){\r\n            const n = this.mouseAction.sources[i];\r\n            this.mouseAction.previews[i].setX(n.getX() + this.mouseAction.dx);\r\n            this.mouseAction.previews[i].setTime(n.getStart() + this.mouseAction.dt, n.getEnd() + this.mouseAction.dt);\r\n            this.mouseAction.previews[i].setTimeScale(this.z);\r\n          }\r\n        }\r\n        break;\r\n      }\r\n    }\r\n  }\r\n  resolveMouseAction(){ // process input\r\n    if(!this.mouseAction) return;\r\n    switch(this.mouseAction.type){\r\n      case Actions.PlaceSVBlock:\r\n        if(this.mouseAction.t !== this.mouseTAligned)\r\n          this.linked.addBlock(new _SvBlock_mjs__WEBPACK_IMPORTED_MODULE_4__.SvBlock(_SvBlock_mjs__WEBPACK_IMPORTED_MODULE_4__.SvBlock.Operation.ADD, this.mouseAction.x, Math.min(this.mouseAction.t, this.mouseTAligned), Math.abs(this.mouseTAligned - this.mouseAction.t)));\r\n        break;\r\n      case Actions.MoveSelection:\r\n        for(let i = 0; i < this.mouseAction.sources.length; i ++){\r\n          const n = this.mouseAction.previews[i];\r\n          this.mouseAction.sources[i].setX(n.getX());\r\n          this.mouseAction.sources[i].setTime(n.getStart(), n.getEnd());\r\n          this.mouseAction.sources[i].setTimeScale(this.z);\r\n        }\r\n        // for(const n of this.mouseAction.sources){\r\n        //   // update position\r\n        // }\r\n        // console.log('dt', this.mouseAction.dt, 'dx', this.mouseAction.dx);\r\n    }\r\n    this.abortMouseAction();\r\n  }\r\n  abortMouseAction(){ // cleanup previews\r\n    if(!this.mouseAction) return;\r\n    switch(this.mouseAction.type){\r\n      case Actions.PlaceSVBlock:\r\n        this.mouseAction.preview.destroy();\r\n        break;\r\n      case Actions.MoveSelection:\r\n        for(const p of this.mouseAction.previews) p.destroy();\r\n    }\r\n    this.mouseAction = null;\r\n  }\r\n}\r\n\r\nclass Project {\r\n  constructor(){\r\n    this.metadata = {};\r\n    this.notes = [];\r\n    this.timingPoints = [];\r\n    this.blocks = [];\r\n    this.editor = null;\r\n    this.songAudio = null;\r\n  }\r\n  openEditor(){\r\n    if(this.editor) throw 'project editor already opened';\r\n    this.editor = new ProjectEditor(this);\r\n  }\r\n  closeEditor(){\r\n    this.editor?.destroy();\r\n    this.editor = null;\r\n  }\r\n  loadResources(files){\r\n    const audioFile = files.filter(x => x.name === this.metadata.General.AudioFilename)[0];\r\n    if(!audioFile) throw \"audio file not found!\";\r\n    const reader = new FileReader();\r\n    reader.addEventListener('load', () => {\r\n      this.songAudio = new Howl({\r\n        src: reader.result,\r\n        format: audioFile.name.split('.').pop().toLowerCase() // always give file extension: this is optional but helps\r\n      });\r\n      this.songAudio.once('load', () => console.log(\"Audio is loaded\"));\r\n    });\r\n    reader.readAsDataURL(audioFile);\r\n  }\r\n  // loads resources from jsZip object instead of filenames\r\n  // TODO: this should be able to be merged with loadResources\r\n  async loadResourcesZip(jsZip) {\r\n    const audioFile = jsZip.files[this.metadata.General.AudioFilename];\r\n\r\n    if (!audioFile) throw \"audio file not found!\";\r\n    // blob, we need to convert to base64url\r\n    const audioData = await audioFile.async(\"blob\");\r\n\r\n    const reader = new FileReader();\r\n\r\n    reader.addEventListener(\"load\", () => {\r\n      this.songAudio = new Howl({\r\n        src: reader.result,\r\n        format: audioFile.name.split(\".\").pop().toLowerCase(), // always give file extension: this is optional but helps\r\n      });\r\n      this.songAudio.once(\"load\", () => console.log(\"Audio is loaded\"));\r\n    });\r\n\r\n    reader.readAsDataURL(audioData);\r\n  }\r\n  addBlock(){\r\n    for(const block of arguments){\r\n      this.blocks.push(block);\r\n      this.editor?.addBlock(block);\r\n    }\r\n    // TODO: X shifting if collisions\r\n  }\r\n  removeBlock(){\r\n    for(const block of arguments){\r\n      let i = this.blocks.indexOf(block); // bin search?\r\n      if(i >= 0){\r\n        this.blocks.splice(i, 1);\r\n      }\r\n    }\r\n  }\r\n  calculateSpeedOutput(){\r\n    this.editor?.app.stop();\r\n    let _start = performance.now();\r\n    this.blocks.sort((a,b) => a.x-b.x || a.t-b.t); // TODO : check for collisions ?? (currently assumes no collision)\r\n    this.speed = [...new Array(this.notes[this.notes.length-1].getEnd())].map(() => 1);\r\n    for(const block of this.blocks) block.applyOnto(this.speed);\r\n    this.editor?.app.start();\r\n    console.log(\"== total calculation time\", 0|(performance.now()-_start), \"ms\")\r\n  }\r\n}\r\n\r\nconst sortByTime = arr => arr.sort((a,b) => a.t-b.t);\r\n\r\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (Project);\r\n\r\n\n\n//# sourceURL=webpack://sv-editor2/./modules/Project.mjs?");

/***/ }),

/***/ "./modules/SvBlock.mjs":
/*!*****************************!*\
  !*** ./modules/SvBlock.mjs ***!
  \*****************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"SvBlock\": () => (/* binding */ SvBlock),\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony import */ var _PFunc_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./PFunc.mjs */ \"./modules/PFunc.mjs\");\n\r\n\r\nconst OperationEnum = {};\r\nconst OperationNames = {};\r\nconst Operations = {\r\n  /*\r\n  Operation: fn(x, y)\r\n    x[] : current sv\r\n    y[] : sv of block being applied\r\n  */\r\n  set: (x, y) => y,\r\n  add: (x, y) => x+y,\r\n  subtract: (x, y) => x-y,\r\n  multiply: (x, y) => x*y,\r\n  divide: (x, y) => x/y,\r\n  intensify: (x) => x, // TODO\r\n  normalize: (x) => x, // TODO\r\n};\r\nObject.keys(Operations).forEach(operation => {\r\n  const symbol = Symbol('sv:'+operation.toLowerCase());\r\n  OperationEnum[operation.toUpperCase()] = symbol;\r\n  OperationNames[symbol] = operation;\r\n  Operations[symbol] = Operations[operation];\r\n  // i feel like this aint very good but uhh well its readable at least???\r\n});\r\n\r\nclass SvBlock {\r\n  static Operation = OperationEnum;\r\n  constructor(operation=SvBlock.Operation.SET, col=0, t=0, duration=0){\r\n    // if(t !== Math.round(t)) throw `expected integer t, observed t=${t}`;\r\n    this.x = col;\r\n    this.operation = operation;\r\n    this.func = new _PFunc_mjs__WEBPACK_IMPORTED_MODULE_0__.PFunc(this);\r\n    this.t = t;\r\n    this.duration = duration;\r\n  }\r\n  clone(){\r\n    const n = new SvBlock(this.operation, this.x, this.t, this.duration);\r\n    n.func = this.func;\r\n    return n; // maybe Object.assign ? mayb\r\n  }\r\n  getStart(){\r\n    return this.t;\r\n  }\r\n  getEnd(){\r\n    return this.t + this.duration;\r\n  }\r\n  getX(){\r\n    return this.x;\r\n  }\r\n  setStart(t){\r\n    this.t = t;\r\n  }\r\n  setEnd(t){\r\n    this.duration = t - this.t;\r\n  }\r\n  setDuration(t){\r\n    this.duration = t;\r\n  }\r\n  setTime(start, end){\r\n    this.t = start;\r\n    this.duration = end - start;\r\n  }\r\n  setX(x){\r\n    this.x = x;\r\n  }\r\n  getLabel(){\r\n    return OperationNames[this.operation] + \"\\n\" + this.func.getLabel();\r\n  }\r\n  integrate(a, b){ return this.func.integrate(a-this.t, b-this.t); }\r\n  evaluate(t){ return this.func.evaluate((t-this.t) / this.duration); }\r\n  /*\r\n  setPoint(t, x){\r\n    this.func.setPoint(t, x);\r\n  }\r\n  offsetX(k){\r\n    this.func.nodes.forEach(node => node.x += k);\r\n  }\r\n  offsetT(k){ this.func.nodes.forEach(node => node.t += k); }\r\n  scaleX(k, a, b){\r\n    if(a !== void 0 && b !== void 0){\r\n      b -= 1;\r\n      this.func.setPoint(a, this.func.evaluate(a)*k);\r\n      this.func.setPoint(b, this.func.evaluate(b));\r\n      for(const node of this.func.nodes)\r\n        if(node.x > a || node.y < b)\r\n          node.x *= k;\r\n    }else this.func.nodes.forEach(node => node.x *= k);\r\n  }\r\n  scaleT(k){ this.func.nodes.forEach(node => node.t *= k); }\r\n  splice(t){ // cuts off second half from instance and returns it\r\n    if(t < 0 || t > this.duration) throw 'invalid splice range';\r\n    const remainder = new SvBlock(this.operation);\r\n    remainder.duration = this.duration - t;\r\n    remainder.t = this.t + t;\r\n    remainder.func = this.func.splice(t);\r\n    remainder.func.linked = remainder;\r\n    this.duration = t;\r\n    return remainder;\r\n  }\r\n  */\r\n  applyOnto(velocityArray/*, resolution*/){ // TODO : resolution for fast rendering??\r\n    // consider binary index tree?\r\n    let start = this.t, end = start + this.duration;\r\n    if(start !== Math.round(start) || end !== Math.round(end)) throw [\"expected integer times\", this];\r\n\r\n    let y = null, func;\r\n    switch(this.operation){\r\n      case SvBlock.Operation.SET:\r\n      case SvBlock.Operation.ADD:\r\n      case SvBlock.Operation.SUBTRACT:\r\n      case SvBlock.Operation.MULTIPLY:\r\n      case SvBlock.Operation.DIVIDE:\r\n      case SvBlock.Operation.INTENSIFY:\r\n        func = Operations[this.operation];\r\n        if(this.func.isConstant()) y = this.evaluate(start);\r\n        break;\r\n      case SvBlock.Operation.NORMALIZE:\r\n        func = Operations.multiply;\r\n        let displacement = 0;\r\n        for(let x = Math.round(start); x < end; x ++) displacement += velocityArray[x];\r\n        y = this.evaluate(start) * (end - start) / displacement;\r\n        break;\r\n    }\r\n    for(let t = start; t < end; t ++){\r\n      velocityArray[t] = func(velocityArray[t], y !== null ? y : this.evaluate(t));\r\n    }\r\n    return velocityArray;\r\n  }\r\n  snapToMs(opts){\r\n    /*\r\n      bool: useSelfForUnknown: when snapping but theres undefined parts\r\n    */\r\n    this.func.snapToMs(this.t, opts);\r\n  }\r\n}\r\n\r\n\r\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (SvBlock);\r\n\n\n//# sourceURL=webpack://sv-editor2/./modules/SvBlock.mjs?");

/***/ }),

/***/ "./modules/SvBuilder.mjs":
/*!*******************************!*\
  !*** ./modules/SvBuilder.mjs ***!
  \*******************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"SvBuilder\": () => (/* binding */ SvBuilder),\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony import */ var _Project_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Project.mjs */ \"./modules/Project.mjs\");\n/* harmony import */ var _SvBlock_mjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./SvBlock.mjs */ \"./modules/SvBlock.mjs\");\n\r\n\r\n\r\nclass Point {\r\n  constructor(t, x){\r\n    this.x = x;\r\n    this.t = t;\r\n  }\r\n}\r\n\r\nclass SvBuilder {\r\n  constructor(){\r\n    this.sorted = true;\r\n    this.aligned = true;\r\n    this.points = [];\r\n  }\r\n  addPoint(t, x){\r\n    this.sorted = false;\r\n    if(t !== Math.round(t)) this.aligned = false;\r\n    this.points.push(new Point(t, x));\r\n  }\r\n  sort(){\r\n    (0,_Project_mjs__WEBPACK_IMPORTED_MODULE_0__.sortByTime)(this.points);\r\n    this.sorted = true;\r\n  }\r\n  cull(){\r\n    if(!this.sorted) this.sort();\r\n    for(let i = this.points.length-1; i > 0; i --){\r\n      if(this.points[i].x == this.points[i-1].x) this.points.splice(i, 1);\r\n    }\r\n  }\r\n  scaleX(k){\r\n    for(const point of this.points) point.x *= k;\r\n  }\r\n  integrate(a, b){\r\n    if(!this.sorted) this.sort();\r\n\r\n    let l = 0, r = this.points.length-1, m, lm;\r\n    while(l <= r){\r\n      m = ~~((l+r)/2); // t----  A t1---  B\r\n      // console.log(l, r, m);\r\n      if(this.points[m+1]?.t > a) r = (lm = m)-1;\r\n      else if(this.points[m+1]?.t < a) l = (lm = m)+1;\r\n      else if(this.points[m+1]?.t == a) {\r\n        lm = m+1;\r\n        break;\r\n      } else break;\r\n    }\r\n    // console.log(a, this.points.slice(lm-2,lm+4), this.points[lm]);\r\n    let sum = 0;\r\n    let t = a, nt; // b -= 1;\r\n    for(let i = lm; t < b; i ++){\r\n      nt = Math.max(t, Math.min(b, i+1 < this.points.length ? this.points[i+1].t : b));\r\n      // if(help)console.log(t, nt, '->', Math.max(0, nt-t), \"@\", this.points[i].x);\r\n      sum += (nt-t) * this.points[i].x;\r\n      t = nt;\r\n    }\r\n    return sum;\r\n  }\r\n  align(){\r\n    let temp = [];\r\n    let t = Math.floor(this.points[0].t);\r\n    let carry = (this.points[0].t - t) * this.points[0].x;\r\n    // ... 1----2----3----4----5---- ...\r\n    //       aaabbbbbbbbbbcc\r\n    //       aaacc\r\n    //       dd\r\n    for(let i = 0; i < this.points.length-1; i ++){\r\n      let velocity = this.points[i].x;\r\n      let curr = this.points[i].t;\r\n      let next = this.points[i+1].t;\r\n      if(Math.floor(curr) === Math.floor(next)){\r\n        // section d\r\n        carry += velocity * (next - t);\r\n        t = next;\r\n      }else{\r\n        // section a\r\n        if(curr !== Math.round(curr)){\r\n          carry += velocity * (Math.ceil(curr) - t);\r\n          t = Math.ceil(curr);\r\n        }\r\n\r\n        if(carry){\r\n          temp.push(new Point(t-1, carry));\r\n          carry = 0;\r\n        }\r\n        // section b\r\n        if(Math.floor(next) > t){\r\n          temp.push(new Point(t, velocity));\r\n          t = Math.floor(next);\r\n        }\r\n\r\n        // section c\r\n        if(next !== Math.round(next)){\r\n          carry += velocity * (next - t);\r\n        }\r\n      }\r\n    }\r\n    this.points.splice(0);\r\n    this.points = temp;\r\n    // if(carry) console.warn(\"residual at end\", {carry, t});\r\n    this.aligned = true;\r\n  }\r\n  *exportAsBlocks(operation, col, endTime){\r\n    if(!this.sorted) this.sort();\r\n    if(!this.aligned) this.align();\r\n    if(endTime === undefined) endTime = this.points[this.points.length-1].t + 10000;\r\n    // SvBlock constructor(operation=SvBlock.Operation.SET, col=0, t=0, duration=0){\r\n    for(let i = 0; i < this.points.length; i ++){\r\n      const svBlock = new _SvBlock_mjs__WEBPACK_IMPORTED_MODULE_1__.SvBlock(operation, col, this.points[i].t, (i+1 < this.points.length ? this.points[i+1]?.t : endTime) - this.points[i].t);\r\n      svBlock.func.set([0, this.points[i].x]); // [t0, x0]\r\n      if(svBlock.duration > 0) yield svBlock; // NOTE: duplicate will be generated\r\n      else console.warn(\"suppressing svBlocks at same time\", svBlock);\r\n    }\r\n  }\r\n}\r\n\r\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (SvBuilder);\r\n\r\n\n\n//# sourceURL=webpack://sv-editor2/./modules/SvBuilder.mjs?");

/***/ }),

/***/ "./modules/TimingPoint.mjs":
/*!*********************************!*\
  !*** ./modules/TimingPoint.mjs ***!
  \*********************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"TimingPoint\": () => (/* binding */ TimingPoint),\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\nclass TimingPoint {\r\n  constructor(t=0, bpm=120, meter=4){\r\n    this.t = t;\r\n    this.bpm = bpm;\r\n    this.meter = meter;\r\n  }\r\n}\r\n\r\n\r\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (TimingPoint);\r\n\n\n//# sourceURL=webpack://sv-editor2/./modules/TimingPoint.mjs?");

/***/ }),

/***/ "./modules/codecs/osuCodec.mjs":
/*!*************************************!*\
  !*** ./modules/codecs/osuCodec.mjs ***!
  \*************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"decode\": () => (/* binding */ decode),\n/* harmony export */   \"encode\": () => (/* binding */ encode)\n/* harmony export */ });\n/* harmony import */ var _Project_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../Project.mjs */ \"./modules/Project.mjs\");\n/* harmony import */ var _Notes_mjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../Notes.mjs */ \"./modules/Notes.mjs\");\n/* harmony import */ var _TimingPoint_mjs__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../TimingPoint.mjs */ \"./modules/TimingPoint.mjs\");\n/* harmony import */ var _SvBlock_mjs__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../SvBlock.mjs */ \"./modules/SvBlock.mjs\");\n/* harmony import */ var _SvBuilder_mjs__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../SvBuilder.mjs */ \"./modules/SvBuilder.mjs\");\n\r\n\r\n\r\n\r\n\r\n\r\nfunction calculateBaseBpm(project){\r\n  const bpms = {};\r\n  let baseBpm = 1;\r\n  let baseBpmDuration = 0;\r\n  const start = project.notes[0].t;\r\n  let current = start;\r\n  const end = project.notes[project.notes.length-1].getEnd();\r\n  let prevBpm = null;\r\n  for(const {t, bpm} of project.timingPoints.concat({t:end, bpm:0})){\r\n    let x = prevBpm || bpm;\r\n    bpms[x] = (bpms[x]||0) + (t-current);\r\n    if(bpms[x] > baseBpmDuration){ // TODO: check baseBpm behavior when theres a tie\r\n      baseBpm = x;\r\n      baseBpmDuration = bpms[x];\r\n    }\r\n    // if(bpms[bpm] === (baseBpmDuration = Math.max(baseBpm, bpms[bpm]))) baseBpm = bpm; // lol\r\n    current = t;\r\n    prevBpm = bpm;\r\n  }\r\n  // console.log(bpms, baseBpm); // WARNING : might be broken but works good enough for now\r\n  return {bpms, baseBpm};\r\n}\r\n\r\nfunction decode(text){\r\n  const project = new _Project_mjs__WEBPACK_IMPORTED_MODULE_0__.Project();\r\n  text = text.replace(/\\r/g, '');\r\n  let state = null;\r\n  let columnCount = 4;\r\n  let start = Infinity, end = -Infinity;\r\n  let bpm, sv, velocity = new _SvBuilder_mjs__WEBPACK_IMPORTED_MODULE_4__.SvBuilder, normalization = new _SvBuilder_mjs__WEBPACK_IMPORTED_MODULE_4__.SvBuilder;\r\n  for(const line of text.split('\\n')){\r\n    if(!line) continue;\r\n    // console.log(line);\r\n    // if(/^\\[[^\\]]+\\]$/.test(line)) state = line.replace(/[\\[\\]]/g, ''); // welp apparently regex is really slow... https://jsbench.me/sel7a2xeh1/1 ; it has the bonus of being easier to write tho haha\r\n    if(!project.metadata.fileFormat) project.metadata.fileFormat = line;\r\n    if(line[0] === \"[\" && line[line.length-1] === \"]\"){\r\n      if(state === \"Difficulty\") columnCount = +project.metadata.Difficulty.CircleSize;\r\n      state = line.substring(1, line.length-1);\r\n    } else {\r\n      let spaceAfterColonInDelimiter = 0;\r\n      switch(state){\r\n        case \"General\": // just setting up the metadata stuff\r\n        case \"Editor\":\r\n          spaceAfterColonInDelimiter = 1;\r\n        case \"Metadata\":\r\n        case \"Difficulty\":\r\n          const delimiter = spaceAfterColonInDelimiter ? ': ' : ':'; // i cant believe the spacing aint consistent :sob:\r\n          // console.log(state, `[${delimiter}]`);\r\n          const data = line.split(delimiter);\r\n          if(!(state in project.metadata)) project.metadata[state] = {};\r\n          project.metadata[state][data[0]] = data[1];\r\n          spaceAfterColonInDelimiter = 0; // if its NOT General or Editor, then it'll stay 0\r\n          break;\r\n        case \"Events\": // TODO: take the bg here and just throw the sb stuff into cache for export\r\n          if(!(state in project.metadata)) project.metadata[state] = \"\";\r\n          project.metadata[state] += line + \"\\n\";\r\n          break;\r\n        case \"TimingPoints\": { // separate BPM & SV here, probably the only codec stuff happens here haha\r\n          /*\r\n          time,beatLength,meter,sampleSet,sampleIndex,volume,uninherited,effects\r\n          0int,1float,    2int, 3int,     4int,       5int,  6bool(0/1), 7int\r\n          effects: bit0 - kiai, bit3 - ignore first barline\r\n          */\r\n          const data = line.split(',').map(x => isNaN(x) ? x : +x);\r\n          const t = data[0];\r\n          const uninherited = !!data[6];\r\n          const mspb = Math.abs(data[1]);\r\n          // TODO: implement other timingpoint data\r\n          if(uninherited){ // scale to base bpm after we figure out whatever it is (assume basebpm:=1 initially)\r\n            sv = bpm = 60000/mspb;\r\n            if(bpm > 10 && bpm <= 5000) project.timingPoints.push(new _TimingPoint_mjs__WEBPACK_IMPORTED_MODULE_2__.TimingPoint(t, bpm, data[2]));\r\n          }else{\r\n            sv = 100/mspb; // what is speed is\r\n            // TODO : add option for parsing clamping\r\n            // sv = Math.min(Math.max(100/mspb, 0.01), 10); // osu 0.01-10.00 clamping\r\n            sv = bpm * sv; // equivalent bpm speed\r\n          }\r\n          velocity.addPoint(t, sv); // WARNING: some jank stuff might happen with points at the same time ??\r\n          break;\r\n        } // doin the weird brace thingy in switch/case for scoping\r\n        case \"HitObjects\": { // yeeters into the notes array\r\n          /*\r\n          RICE   - x,y,time,type=1  ,hitSound,objectParams,hitSample\r\n          NOODLE - x,y,time,type=128,hitSound,endTime:hitSample\r\n\r\n          hitSample format\r\n          normalSet:additionSet:index:volume:filename\r\n          0:0:0:0:   [default]\r\n          */ // so inconsistent :c ... but at least i'm actually reading the osu! docs more carefully for once, sorta\r\n          let n;\r\n          const data = line.split(/[,:]/).map(x => isNaN(x) ? x : +x);\r\n          const col = Math.min(Math.max(Math.floor(data[0] * columnCount / 512), 0), columnCount - 1);\r\n          if(data[3] < 100){ // rice\r\n            n = new _Notes_mjs__WEBPACK_IMPORTED_MODULE_1__.Note(col, data[2]);\r\n          } else { // noodle\r\n            n = new _Notes_mjs__WEBPACK_IMPORTED_MODULE_1__.LongNote(col, data[2], data[5]);\r\n          }\r\n          start = Math.min(start, n.getStart());\r\n          end = Math.max(end, n.getEnd());\r\n          /* n.hitsound = data[3]\r\n          n.sample = data[6+] */ // TODO: implement hitsounds\r\n          project.notes.push(n);\r\n          break;\r\n        }\r\n      }\r\n    }\r\n  }\r\n  // post read processing (maybe move tp processing here if things break)\r\n  (0,_Project_mjs__WEBPACK_IMPORTED_MODULE_0__.sortByTime)(project.notes);\r\n  (0,_Project_mjs__WEBPACK_IMPORTED_MODULE_0__.sortByTime)(project.timingPoints);\r\n  velocity.sort();\r\n\r\n  // globalSvBlock.snapToMs({useSelfForUnknown: true});\r\n  // console.log(globalSvBlock);\r\n\r\n  // base bpm\r\n  const baseBpm = calculateBaseBpm(project).baseBpm;\r\n  let firstTimingPoint = project.timingPoints[0].t;\r\n  velocity.scaleX(1/baseBpm);\r\n\r\n  // normalization\r\n  // const globalSvBlock = new SvBlock(SvBlock.Operation.SET);\r\n  // const globalNormalizationBlock = new SvBlock(SvBlock.Operation.NORMALIZE, 4);\r\n  const notePositions = [...new Set(project.notes.map(x => [x.t, x.t$]).flat().filter(x => x !== void 0))].sort((a,b)=>a-b); // splits\r\n\r\n  if(notePositions[0] > firstTimingPoint) notePositions.unshift(firstTimingPoint);\r\n\r\n  // console.log(notePositions);\r\n\r\n  // const speeds = globalSvBlock.func;\r\n  for(let i = 0; i < notePositions.length-1; i ++){\r\n    const normalized = notePositions[i+1] - notePositions[i];\r\n    const observed = velocity.integrate(notePositions[i], notePositions[i+1]);\r\n    // console.log(notePositions[i], notePositions[i+1], normalized, observed, observed/normalized);\r\n    const average = observed/normalized;\r\n    // // globalSvBlock.scaleX(1/average, notePositions[i]-notePositions[0], notePositions[i+1]-notePositions[0]);\r\n    // globalNormalizationBlock.setPoint(notePositions[i]-notePositions[0], average);\r\n    normalization.addPoint(notePositions[i], average);\r\n  }\r\n\r\n  // globalSvBlock.offsetT(-Math.floor(firstTimingPoint)); // NOTE : might be okay to keep original offsets\r\n  // globalSvBlock.func.nodes[0].t = 0;\r\n  // globalSvBlock.t = Math.floor(firstTimingPoint);\r\n  // globalSvBlock.duration = end-firstTimingPoint;\r\n  // globalNormalizationBlock.t = notePositions[0];\r\n  // globalNormalizationBlock.duration = notePositions[notePositions.length-1] - notePositions[0];\r\n\r\n  /*const blocks = [globalSvBlock];\r\n  let splits = [...new Set(project.notes.map(x => [x.t, x.t$]).flat().filter(x => x !== void 0 && x > firstTimingPoint ))].sort((a,b)=>a-b);\r\n  let prev = null;\r\n  for(let i = 0; i < splits.length; i += 10){\r\n    blocks.push(blocks[blocks.length-1].splice(splits[i]-splits[prev]||firstTimingPoint));\r\n    prev = i;\r\n  }\r\n  blocks.forEach(block => project.svColumns[0].addBlock(block));*/\r\n\r\n  // project.addBlock(globalSvBlock);\r\n  // project.addBlock(globalNormalizationBlock); // TODO: do that [...arguments] thingy\r\n  // console.log(velocity, normalization);\r\n  velocity.cull();\r\n  // normalization.cull(); // TODO: export using known note positions\r\n  project.addBlock(...velocity.exportAsBlocks(_SvBlock_mjs__WEBPACK_IMPORTED_MODULE_3__.SvBlock.Operation.SET, 0, end));\r\n  project.addBlock(...normalization.exportAsBlocks(_SvBlock_mjs__WEBPACK_IMPORTED_MODULE_3__.SvBlock.Operation.NORMALIZE, 4, end));\r\n  return project;\r\n}\r\nfunction encode(project){\r\n  project.calculateSpeedOutput();\r\n\r\n  // TODO: compile to osu :3c\r\n  const m = project.metadata; // alias cuz dont wanna type all of it out :skull:\r\n  let raw = `${m.fileFormat}`;\r\n  [{ section: \"General\", delimiter: ': ' },\r\n  { section: \"Editor\", delimiter: ': ' },\r\n  { section: \"Metadata\", delimiter: ':' },\r\n  { section: \"Difficulty\", delimiter: ':' }].forEach(({section, delimiter}) => {\r\n    raw += `\\n\\n[${section}]\\n` + Object.entries(m[section]).map(x => x.join(delimiter)).join('\\n');\r\n  });\r\n  raw += `\\n\\n[Events]\\n` + m.Events;\r\n\r\n  raw += `\\n[TimingPoints]`;\r\n  let tp = -1, currentTimingPoint;\r\n  let bpmChanged = false;\r\n  let prevSpeed = null;\r\n  const baseBpm = calculateBaseBpm(project).baseBpm;\r\n\r\n  raw += `\\n0,${60000/baseBpm},${4},2,0,30,1,0`; // osu dies on green tp without red tp to use\r\n  for(let t = Math.min(project.notes[0].t, Math.floor(project.timingPoints[0].t+1)); t < project.speed.length; t ++){\r\n    // if(t > 10000) break;\r\n\r\n    let uninherited, inherited;\r\n    while(tp<0 || project.timingPoints[tp+1]?.t <= t){\r\n      tp ++;\r\n      currentTimingPoint = project.timingPoints[tp];\r\n      // TODO : export other properties of timingpoint\r\n      uninherited = `\\n${currentTimingPoint.t},${60000/currentTimingPoint.bpm},${currentTimingPoint.meter},2,0,30,1,0`;\r\n      /*\r\n      time,beatLength,meter,sampleSet,sampleIndex,volume,uninherited,effects\r\n      0int,1float,    2int, 3int,     4int,       5int,  6bool(0/1), 7int\r\n      effects: bit0 - kiai, bit3 - ignore first barline\r\n      */\r\n      prevSpeed = null;\r\n    }\r\n    // let exportSpeed = project.speed[t] / (currentTimingPoint.bpm / baseBpm);\r\n    let exportSpeed = project.speed[t] / currentTimingPoint.bpm * baseBpm;\r\n    if(prevSpeed === exportSpeed){\r\n      // necessary to reset bpm (if needed)\r\n      raw += (uninherited||\"\") + (inherited||\"\");\r\n      continue;\r\n    } prevSpeed = exportSpeed;\r\n    if(exportSpeed >= 0.01 && exportSpeed <= 10){ // TODO : accumulator so its not so dumb\r\n      // within the bounds of the clamp\r\n      if(bpmChanged){ // only reset bpm if we're all good again to be using current bpm\r\n        // console.log(t);\r\n        // TODO : change bpm onto original snap once possible (so the lines arent dumb)\r\n        uninherited = `\\n${t},${60000/currentTimingPoint.bpm},${currentTimingPoint.meter},2,0,30,1,0`;\r\n        bpmChanged = false;\r\n      }\r\n      inherited = `\\n${t},${-100/exportSpeed},${currentTimingPoint.meter},2,0,30,0,0`;\r\n    }else{\r\n      // console.log(exportSpeed, t);\r\n      // something 0.01x (100) or 10x (0.1) that we can reach\r\n      const coef = Math.max(0.1, Math.random()*100);\r\n      const bpm = Math.min(Math.max(project.speed[t], 0.0001), 14000) * baseBpm  * coef; // speed = bpm/baseBpm ;; bpm = speed * base BPM\r\n      // const sv = project.speed[t] / bpm * baseBpm;\r\n      // const sv = SP / (SP * baseBpm * coef) * baseBpm = 1/ coef;\r\n      const sv = 1 / coef;\r\n      if(sv < 0.01 || sv > 10) console.warn(\"bruh wtf\", bpm, coef, sv, t);\r\n      uninherited = `\\n${t},${60000/bpm},${currentTimingPoint.meter},2,0,30,1,0`;\r\n      inherited = `\\n${t},${-100/sv},${currentTimingPoint.meter},2,0,30,0,0`;\r\n      bpmChanged = true;\r\n    }\r\n    // if(uninherited) bpmChanged = true;\r\n    // if(uninherited) console.log(uninherited, inherited, bpmChanged);\r\n    raw += (uninherited||\"\") + (inherited||\"\");\r\n  }\r\n\r\n  raw += `\\n\\n\\n[HitObjects]\\n` + project.notes.map(note => {\r\n    // TODO: export other properties of hitobject\r\n    let x = 0|((512/m.Difficulty.CircleSize)*(0.5+note.x));\r\n    let t = 0|note.t;\r\n    let tail = note instanceof _Notes_mjs__WEBPACK_IMPORTED_MODULE_1__.LongNote ? `128,0,${note.t$}:` : '1,0,';\r\n    let hitSample = '0:0:0:0:';\r\n    return `${x},192,${t},${tail}${hitSample}`;\r\n  }).join('\\n');\r\n  return raw;\r\n}\r\n\r\n\r\n\n\n//# sourceURL=webpack://sv-editor2/./modules/codecs/osuCodec.mjs?");

/***/ }),

/***/ "./node_modules/@pixi/math/dist/esm/math.mjs":
/*!***************************************************!*\
  !*** ./node_modules/@pixi/math/dist/esm/math.mjs ***!
  \***************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"Circle\": () => (/* binding */ Circle),\n/* harmony export */   \"DEG_TO_RAD\": () => (/* binding */ DEG_TO_RAD),\n/* harmony export */   \"Ellipse\": () => (/* binding */ Ellipse),\n/* harmony export */   \"Matrix\": () => (/* binding */ Matrix),\n/* harmony export */   \"ObservablePoint\": () => (/* binding */ ObservablePoint),\n/* harmony export */   \"PI_2\": () => (/* binding */ PI_2),\n/* harmony export */   \"Point\": () => (/* binding */ Point),\n/* harmony export */   \"Polygon\": () => (/* binding */ Polygon),\n/* harmony export */   \"RAD_TO_DEG\": () => (/* binding */ RAD_TO_DEG),\n/* harmony export */   \"Rectangle\": () => (/* binding */ Rectangle),\n/* harmony export */   \"RoundedRectangle\": () => (/* binding */ RoundedRectangle),\n/* harmony export */   \"SHAPES\": () => (/* binding */ SHAPES),\n/* harmony export */   \"Transform\": () => (/* binding */ Transform),\n/* harmony export */   \"groupD8\": () => (/* binding */ groupD8)\n/* harmony export */ });\n/*!\n * @pixi/math - v6.5.8\n * Compiled Sun, 23 Oct 2022 23:01:45 UTC\n *\n * @pixi/math is licensed under the MIT License.\n * http://www.opensource.org/licenses/mit-license\n */\n/**\n * Two Pi.\n * @static\n * @member {number}\n * @memberof PIXI\n */\nvar PI_2 = Math.PI * 2;\n/**\n * Conversion factor for converting radians to degrees.\n * @static\n * @member {number} RAD_TO_DEG\n * @memberof PIXI\n */\nvar RAD_TO_DEG = 180 / Math.PI;\n/**\n * Conversion factor for converting degrees to radians.\n * @static\n * @member {number}\n * @memberof PIXI\n */\nvar DEG_TO_RAD = Math.PI / 180;\n/**\n * Constants that identify shapes, mainly to prevent `instanceof` calls.\n * @static\n * @memberof PIXI\n * @enum {number}\n * @property {number} POLY Polygon\n * @property {number} RECT Rectangle\n * @property {number} CIRC Circle\n * @property {number} ELIP Ellipse\n * @property {number} RREC Rounded Rectangle\n */\nvar SHAPES;\n(function (SHAPES) {\n    SHAPES[SHAPES[\"POLY\"] = 0] = \"POLY\";\n    SHAPES[SHAPES[\"RECT\"] = 1] = \"RECT\";\n    SHAPES[SHAPES[\"CIRC\"] = 2] = \"CIRC\";\n    SHAPES[SHAPES[\"ELIP\"] = 3] = \"ELIP\";\n    SHAPES[SHAPES[\"RREC\"] = 4] = \"RREC\";\n})(SHAPES || (SHAPES = {}));\n\n/**\n * The Point object represents a location in a two-dimensional coordinate system, where `x` represents\n * the position on the horizontal axis and `y` represents the position on the vertical axis\n * @class\n * @memberof PIXI\n * @implements {IPoint}\n */\nvar Point = /** @class */ (function () {\n    /**\n     * Creates a new `Point`\n     * @param {number} [x=0] - position of the point on the x axis\n     * @param {number} [y=0] - position of the point on the y axis\n     */\n    function Point(x, y) {\n        if (x === void 0) { x = 0; }\n        if (y === void 0) { y = 0; }\n        /** Position of the point on the x axis */\n        this.x = 0;\n        /** Position of the point on the y axis */\n        this.y = 0;\n        this.x = x;\n        this.y = y;\n    }\n    /**\n     * Creates a clone of this point\n     * @returns A clone of this point\n     */\n    Point.prototype.clone = function () {\n        return new Point(this.x, this.y);\n    };\n    /**\n     * Copies `x` and `y` from the given point into this point\n     * @param p - The point to copy from\n     * @returns The point instance itself\n     */\n    Point.prototype.copyFrom = function (p) {\n        this.set(p.x, p.y);\n        return this;\n    };\n    /**\n     * Copies this point's x and y into the given point (`p`).\n     * @param p - The point to copy to. Can be any of type that is or extends `IPointData`\n     * @returns The point (`p`) with values updated\n     */\n    Point.prototype.copyTo = function (p) {\n        p.set(this.x, this.y);\n        return p;\n    };\n    /**\n     * Accepts another point (`p`) and returns `true` if the given point is equal to this point\n     * @param p - The point to check\n     * @returns Returns `true` if both `x` and `y` are equal\n     */\n    Point.prototype.equals = function (p) {\n        return (p.x === this.x) && (p.y === this.y);\n    };\n    /**\n     * Sets the point to a new `x` and `y` position.\n     * If `y` is omitted, both `x` and `y` will be set to `x`.\n     * @param {number} [x=0] - position of the point on the `x` axis\n     * @param {number} [y=x] - position of the point on the `y` axis\n     * @returns The point instance itself\n     */\n    Point.prototype.set = function (x, y) {\n        if (x === void 0) { x = 0; }\n        if (y === void 0) { y = x; }\n        this.x = x;\n        this.y = y;\n        return this;\n    };\n    Point.prototype.toString = function () {\n        return \"[@pixi/math:Point x=\" + this.x + \" y=\" + this.y + \"]\";\n    };\n    return Point;\n}());\n\nvar tempPoints = [new Point(), new Point(), new Point(), new Point()];\n/**\n * Size object, contains width and height\n * @memberof PIXI\n * @typedef {object} ISize\n * @property {number} width - Width component\n * @property {number} height - Height component\n */\n/**\n * Rectangle object is an area defined by its position, as indicated by its top-left corner\n * point (x, y) and by its width and its height.\n * @memberof PIXI\n */\nvar Rectangle = /** @class */ (function () {\n    /**\n     * @param x - The X coordinate of the upper-left corner of the rectangle\n     * @param y - The Y coordinate of the upper-left corner of the rectangle\n     * @param width - The overall width of the rectangle\n     * @param height - The overall height of the rectangle\n     */\n    function Rectangle(x, y, width, height) {\n        if (x === void 0) { x = 0; }\n        if (y === void 0) { y = 0; }\n        if (width === void 0) { width = 0; }\n        if (height === void 0) { height = 0; }\n        this.x = Number(x);\n        this.y = Number(y);\n        this.width = Number(width);\n        this.height = Number(height);\n        this.type = SHAPES.RECT;\n    }\n    Object.defineProperty(Rectangle.prototype, \"left\", {\n        /** Returns the left edge of the rectangle. */\n        get: function () {\n            return this.x;\n        },\n        enumerable: false,\n        configurable: true\n    });\n    Object.defineProperty(Rectangle.prototype, \"right\", {\n        /** Returns the right edge of the rectangle. */\n        get: function () {\n            return this.x + this.width;\n        },\n        enumerable: false,\n        configurable: true\n    });\n    Object.defineProperty(Rectangle.prototype, \"top\", {\n        /** Returns the top edge of the rectangle. */\n        get: function () {\n            return this.y;\n        },\n        enumerable: false,\n        configurable: true\n    });\n    Object.defineProperty(Rectangle.prototype, \"bottom\", {\n        /** Returns the bottom edge of the rectangle. */\n        get: function () {\n            return this.y + this.height;\n        },\n        enumerable: false,\n        configurable: true\n    });\n    Object.defineProperty(Rectangle, \"EMPTY\", {\n        /** A constant empty rectangle. */\n        get: function () {\n            return new Rectangle(0, 0, 0, 0);\n        },\n        enumerable: false,\n        configurable: true\n    });\n    /**\n     * Creates a clone of this Rectangle\n     * @returns a copy of the rectangle\n     */\n    Rectangle.prototype.clone = function () {\n        return new Rectangle(this.x, this.y, this.width, this.height);\n    };\n    /**\n     * Copies another rectangle to this one.\n     * @param rectangle - The rectangle to copy from.\n     * @returns Returns itself.\n     */\n    Rectangle.prototype.copyFrom = function (rectangle) {\n        this.x = rectangle.x;\n        this.y = rectangle.y;\n        this.width = rectangle.width;\n        this.height = rectangle.height;\n        return this;\n    };\n    /**\n     * Copies this rectangle to another one.\n     * @param rectangle - The rectangle to copy to.\n     * @returns Returns given parameter.\n     */\n    Rectangle.prototype.copyTo = function (rectangle) {\n        rectangle.x = this.x;\n        rectangle.y = this.y;\n        rectangle.width = this.width;\n        rectangle.height = this.height;\n        return rectangle;\n    };\n    /**\n     * Checks whether the x and y coordinates given are contained within this Rectangle\n     * @param x - The X coordinate of the point to test\n     * @param y - The Y coordinate of the point to test\n     * @returns Whether the x/y coordinates are within this Rectangle\n     */\n    Rectangle.prototype.contains = function (x, y) {\n        if (this.width <= 0 || this.height <= 0) {\n            return false;\n        }\n        if (x >= this.x && x < this.x + this.width) {\n            if (y >= this.y && y < this.y + this.height) {\n                return true;\n            }\n        }\n        return false;\n    };\n    /**\n     * Determines whether the `other` Rectangle transformed by `transform` intersects with `this` Rectangle object.\n     * Returns true only if the area of the intersection is >0, this means that Rectangles\n     * sharing a side are not overlapping. Another side effect is that an arealess rectangle\n     * (width or height equal to zero) can't intersect any other rectangle.\n     * @param {Rectangle} other - The Rectangle to intersect with `this`.\n     * @param {Matrix} transform - The transformation matrix of `other`.\n     * @returns {boolean} A value of `true` if the transformed `other` Rectangle intersects with `this`; otherwise `false`.\n     */\n    Rectangle.prototype.intersects = function (other, transform) {\n        if (!transform) {\n            var x0_1 = this.x < other.x ? other.x : this.x;\n            var x1_1 = this.right > other.right ? other.right : this.right;\n            if (x1_1 <= x0_1) {\n                return false;\n            }\n            var y0_1 = this.y < other.y ? other.y : this.y;\n            var y1_1 = this.bottom > other.bottom ? other.bottom : this.bottom;\n            return y1_1 > y0_1;\n        }\n        var x0 = this.left;\n        var x1 = this.right;\n        var y0 = this.top;\n        var y1 = this.bottom;\n        if (x1 <= x0 || y1 <= y0) {\n            return false;\n        }\n        var lt = tempPoints[0].set(other.left, other.top);\n        var lb = tempPoints[1].set(other.left, other.bottom);\n        var rt = tempPoints[2].set(other.right, other.top);\n        var rb = tempPoints[3].set(other.right, other.bottom);\n        if (rt.x <= lt.x || lb.y <= lt.y) {\n            return false;\n        }\n        var s = Math.sign((transform.a * transform.d) - (transform.b * transform.c));\n        if (s === 0) {\n            return false;\n        }\n        transform.apply(lt, lt);\n        transform.apply(lb, lb);\n        transform.apply(rt, rt);\n        transform.apply(rb, rb);\n        if (Math.max(lt.x, lb.x, rt.x, rb.x) <= x0\n            || Math.min(lt.x, lb.x, rt.x, rb.x) >= x1\n            || Math.max(lt.y, lb.y, rt.y, rb.y) <= y0\n            || Math.min(lt.y, lb.y, rt.y, rb.y) >= y1) {\n            return false;\n        }\n        var nx = s * (lb.y - lt.y);\n        var ny = s * (lt.x - lb.x);\n        var n00 = (nx * x0) + (ny * y0);\n        var n10 = (nx * x1) + (ny * y0);\n        var n01 = (nx * x0) + (ny * y1);\n        var n11 = (nx * x1) + (ny * y1);\n        if (Math.max(n00, n10, n01, n11) <= (nx * lt.x) + (ny * lt.y)\n            || Math.min(n00, n10, n01, n11) >= (nx * rb.x) + (ny * rb.y)) {\n            return false;\n        }\n        var mx = s * (lt.y - rt.y);\n        var my = s * (rt.x - lt.x);\n        var m00 = (mx * x0) + (my * y0);\n        var m10 = (mx * x1) + (my * y0);\n        var m01 = (mx * x0) + (my * y1);\n        var m11 = (mx * x1) + (my * y1);\n        if (Math.max(m00, m10, m01, m11) <= (mx * lt.x) + (my * lt.y)\n            || Math.min(m00, m10, m01, m11) >= (mx * rb.x) + (my * rb.y)) {\n            return false;\n        }\n        return true;\n    };\n    /**\n     * Pads the rectangle making it grow in all directions.\n     * If paddingY is omitted, both paddingX and paddingY will be set to paddingX.\n     * @param paddingX - The horizontal padding amount.\n     * @param paddingY - The vertical padding amount.\n     * @returns Returns itself.\n     */\n    Rectangle.prototype.pad = function (paddingX, paddingY) {\n        if (paddingX === void 0) { paddingX = 0; }\n        if (paddingY === void 0) { paddingY = paddingX; }\n        this.x -= paddingX;\n        this.y -= paddingY;\n        this.width += paddingX * 2;\n        this.height += paddingY * 2;\n        return this;\n    };\n    /**\n     * Fits this rectangle around the passed one.\n     * @param rectangle - The rectangle to fit.\n     * @returns Returns itself.\n     */\n    Rectangle.prototype.fit = function (rectangle) {\n        var x1 = Math.max(this.x, rectangle.x);\n        var x2 = Math.min(this.x + this.width, rectangle.x + rectangle.width);\n        var y1 = Math.max(this.y, rectangle.y);\n        var y2 = Math.min(this.y + this.height, rectangle.y + rectangle.height);\n        this.x = x1;\n        this.width = Math.max(x2 - x1, 0);\n        this.y = y1;\n        this.height = Math.max(y2 - y1, 0);\n        return this;\n    };\n    /**\n     * Enlarges rectangle that way its corners lie on grid\n     * @param resolution - resolution\n     * @param eps - precision\n     * @returns Returns itself.\n     */\n    Rectangle.prototype.ceil = function (resolution, eps) {\n        if (resolution === void 0) { resolution = 1; }\n        if (eps === void 0) { eps = 0.001; }\n        var x2 = Math.ceil((this.x + this.width - eps) * resolution) / resolution;\n        var y2 = Math.ceil((this.y + this.height - eps) * resolution) / resolution;\n        this.x = Math.floor((this.x + eps) * resolution) / resolution;\n        this.y = Math.floor((this.y + eps) * resolution) / resolution;\n        this.width = x2 - this.x;\n        this.height = y2 - this.y;\n        return this;\n    };\n    /**\n     * Enlarges this rectangle to include the passed rectangle.\n     * @param rectangle - The rectangle to include.\n     * @returns Returns itself.\n     */\n    Rectangle.prototype.enlarge = function (rectangle) {\n        var x1 = Math.min(this.x, rectangle.x);\n        var x2 = Math.max(this.x + this.width, rectangle.x + rectangle.width);\n        var y1 = Math.min(this.y, rectangle.y);\n        var y2 = Math.max(this.y + this.height, rectangle.y + rectangle.height);\n        this.x = x1;\n        this.width = x2 - x1;\n        this.y = y1;\n        this.height = y2 - y1;\n        return this;\n    };\n    Rectangle.prototype.toString = function () {\n        return \"[@pixi/math:Rectangle x=\" + this.x + \" y=\" + this.y + \" width=\" + this.width + \" height=\" + this.height + \"]\";\n    };\n    return Rectangle;\n}());\n\n/**\n * The Circle object is used to help draw graphics and can also be used to specify a hit area for displayObjects.\n * @memberof PIXI\n */\nvar Circle = /** @class */ (function () {\n    /**\n     * @param x - The X coordinate of the center of this circle\n     * @param y - The Y coordinate of the center of this circle\n     * @param radius - The radius of the circle\n     */\n    function Circle(x, y, radius) {\n        if (x === void 0) { x = 0; }\n        if (y === void 0) { y = 0; }\n        if (radius === void 0) { radius = 0; }\n        this.x = x;\n        this.y = y;\n        this.radius = radius;\n        this.type = SHAPES.CIRC;\n    }\n    /**\n     * Creates a clone of this Circle instance\n     * @returns A copy of the Circle\n     */\n    Circle.prototype.clone = function () {\n        return new Circle(this.x, this.y, this.radius);\n    };\n    /**\n     * Checks whether the x and y coordinates given are contained within this circle\n     * @param x - The X coordinate of the point to test\n     * @param y - The Y coordinate of the point to test\n     * @returns Whether the x/y coordinates are within this Circle\n     */\n    Circle.prototype.contains = function (x, y) {\n        if (this.radius <= 0) {\n            return false;\n        }\n        var r2 = this.radius * this.radius;\n        var dx = (this.x - x);\n        var dy = (this.y - y);\n        dx *= dx;\n        dy *= dy;\n        return (dx + dy <= r2);\n    };\n    /**\n     * Returns the framing rectangle of the circle as a Rectangle object\n     * @returns The framing rectangle\n     */\n    Circle.prototype.getBounds = function () {\n        return new Rectangle(this.x - this.radius, this.y - this.radius, this.radius * 2, this.radius * 2);\n    };\n    Circle.prototype.toString = function () {\n        return \"[@pixi/math:Circle x=\" + this.x + \" y=\" + this.y + \" radius=\" + this.radius + \"]\";\n    };\n    return Circle;\n}());\n\n/**\n * The Ellipse object is used to help draw graphics and can also be used to specify a hit area for displayObjects.\n * @memberof PIXI\n */\nvar Ellipse = /** @class */ (function () {\n    /**\n     * @param x - The X coordinate of the center of this ellipse\n     * @param y - The Y coordinate of the center of this ellipse\n     * @param halfWidth - The half width of this ellipse\n     * @param halfHeight - The half height of this ellipse\n     */\n    function Ellipse(x, y, halfWidth, halfHeight) {\n        if (x === void 0) { x = 0; }\n        if (y === void 0) { y = 0; }\n        if (halfWidth === void 0) { halfWidth = 0; }\n        if (halfHeight === void 0) { halfHeight = 0; }\n        this.x = x;\n        this.y = y;\n        this.width = halfWidth;\n        this.height = halfHeight;\n        this.type = SHAPES.ELIP;\n    }\n    /**\n     * Creates a clone of this Ellipse instance\n     * @returns {PIXI.Ellipse} A copy of the ellipse\n     */\n    Ellipse.prototype.clone = function () {\n        return new Ellipse(this.x, this.y, this.width, this.height);\n    };\n    /**\n     * Checks whether the x and y coordinates given are contained within this ellipse\n     * @param x - The X coordinate of the point to test\n     * @param y - The Y coordinate of the point to test\n     * @returns Whether the x/y coords are within this ellipse\n     */\n    Ellipse.prototype.contains = function (x, y) {\n        if (this.width <= 0 || this.height <= 0) {\n            return false;\n        }\n        // normalize the coords to an ellipse with center 0,0\n        var normx = ((x - this.x) / this.width);\n        var normy = ((y - this.y) / this.height);\n        normx *= normx;\n        normy *= normy;\n        return (normx + normy <= 1);\n    };\n    /**\n     * Returns the framing rectangle of the ellipse as a Rectangle object\n     * @returns The framing rectangle\n     */\n    Ellipse.prototype.getBounds = function () {\n        return new Rectangle(this.x - this.width, this.y - this.height, this.width, this.height);\n    };\n    Ellipse.prototype.toString = function () {\n        return \"[@pixi/math:Ellipse x=\" + this.x + \" y=\" + this.y + \" width=\" + this.width + \" height=\" + this.height + \"]\";\n    };\n    return Ellipse;\n}());\n\n/**\n * A class to define a shape via user defined coordinates.\n * @memberof PIXI\n */\nvar Polygon = /** @class */ (function () {\n    /**\n     * @param {PIXI.IPointData[]|number[]} points - This can be an array of Points\n     *  that form the polygon, a flat array of numbers that will be interpreted as [x,y, x,y, ...], or\n     *  the arguments passed can be all the points of the polygon e.g.\n     *  `new PIXI.Polygon(new PIXI.Point(), new PIXI.Point(), ...)`, or the arguments passed can be flat\n     *  x,y values e.g. `new Polygon(x,y, x,y, x,y, ...)` where `x` and `y` are Numbers.\n     */\n    function Polygon() {\n        var arguments$1 = arguments;\n\n        var points = [];\n        for (var _i = 0; _i < arguments.length; _i++) {\n            points[_i] = arguments$1[_i];\n        }\n        var flat = Array.isArray(points[0]) ? points[0] : points;\n        // if this is an array of points, convert it to a flat array of numbers\n        if (typeof flat[0] !== 'number') {\n            var p = [];\n            for (var i = 0, il = flat.length; i < il; i++) {\n                p.push(flat[i].x, flat[i].y);\n            }\n            flat = p;\n        }\n        this.points = flat;\n        this.type = SHAPES.POLY;\n        this.closeStroke = true;\n    }\n    /**\n     * Creates a clone of this polygon.\n     * @returns - A copy of the polygon.\n     */\n    Polygon.prototype.clone = function () {\n        var points = this.points.slice();\n        var polygon = new Polygon(points);\n        polygon.closeStroke = this.closeStroke;\n        return polygon;\n    };\n    /**\n     * Checks whether the x and y coordinates passed to this function are contained within this polygon.\n     * @param x - The X coordinate of the point to test.\n     * @param y - The Y coordinate of the point to test.\n     * @returns - Whether the x/y coordinates are within this polygon.\n     */\n    Polygon.prototype.contains = function (x, y) {\n        var inside = false;\n        // use some raycasting to test hits\n        // https://github.com/substack/point-in-polygon/blob/master/index.js\n        var length = this.points.length / 2;\n        for (var i = 0, j = length - 1; i < length; j = i++) {\n            var xi = this.points[i * 2];\n            var yi = this.points[(i * 2) + 1];\n            var xj = this.points[j * 2];\n            var yj = this.points[(j * 2) + 1];\n            var intersect = ((yi > y) !== (yj > y)) && (x < ((xj - xi) * ((y - yi) / (yj - yi))) + xi);\n            if (intersect) {\n                inside = !inside;\n            }\n        }\n        return inside;\n    };\n    Polygon.prototype.toString = function () {\n        return \"[@pixi/math:Polygon\"\n            + (\"closeStroke=\" + this.closeStroke)\n            + (\"points=\" + this.points.reduce(function (pointsDesc, currentPoint) { return pointsDesc + \", \" + currentPoint; }, '') + \"]\");\n    };\n    return Polygon;\n}());\n\n/**\n * The Rounded Rectangle object is an area that has nice rounded corners, as indicated by its\n * top-left corner point (x, y) and by its width and its height and its radius.\n * @memberof PIXI\n */\nvar RoundedRectangle = /** @class */ (function () {\n    /**\n     * @param x - The X coordinate of the upper-left corner of the rounded rectangle\n     * @param y - The Y coordinate of the upper-left corner of the rounded rectangle\n     * @param width - The overall width of this rounded rectangle\n     * @param height - The overall height of this rounded rectangle\n     * @param radius - Controls the radius of the rounded corners\n     */\n    function RoundedRectangle(x, y, width, height, radius) {\n        if (x === void 0) { x = 0; }\n        if (y === void 0) { y = 0; }\n        if (width === void 0) { width = 0; }\n        if (height === void 0) { height = 0; }\n        if (radius === void 0) { radius = 20; }\n        this.x = x;\n        this.y = y;\n        this.width = width;\n        this.height = height;\n        this.radius = radius;\n        this.type = SHAPES.RREC;\n    }\n    /**\n     * Creates a clone of this Rounded Rectangle.\n     * @returns - A copy of the rounded rectangle.\n     */\n    RoundedRectangle.prototype.clone = function () {\n        return new RoundedRectangle(this.x, this.y, this.width, this.height, this.radius);\n    };\n    /**\n     * Checks whether the x and y coordinates given are contained within this Rounded Rectangle\n     * @param x - The X coordinate of the point to test.\n     * @param y - The Y coordinate of the point to test.\n     * @returns - Whether the x/y coordinates are within this Rounded Rectangle.\n     */\n    RoundedRectangle.prototype.contains = function (x, y) {\n        if (this.width <= 0 || this.height <= 0) {\n            return false;\n        }\n        if (x >= this.x && x <= this.x + this.width) {\n            if (y >= this.y && y <= this.y + this.height) {\n                var radius = Math.max(0, Math.min(this.radius, Math.min(this.width, this.height) / 2));\n                if ((y >= this.y + radius && y <= this.y + this.height - radius)\n                    || (x >= this.x + radius && x <= this.x + this.width - radius)) {\n                    return true;\n                }\n                var dx = x - (this.x + radius);\n                var dy = y - (this.y + radius);\n                var radius2 = radius * radius;\n                if ((dx * dx) + (dy * dy) <= radius2) {\n                    return true;\n                }\n                dx = x - (this.x + this.width - radius);\n                if ((dx * dx) + (dy * dy) <= radius2) {\n                    return true;\n                }\n                dy = y - (this.y + this.height - radius);\n                if ((dx * dx) + (dy * dy) <= radius2) {\n                    return true;\n                }\n                dx = x - (this.x + radius);\n                if ((dx * dx) + (dy * dy) <= radius2) {\n                    return true;\n                }\n            }\n        }\n        return false;\n    };\n    RoundedRectangle.prototype.toString = function () {\n        return \"[@pixi/math:RoundedRectangle x=\" + this.x + \" y=\" + this.y\n            + (\"width=\" + this.width + \" height=\" + this.height + \" radius=\" + this.radius + \"]\");\n    };\n    return RoundedRectangle;\n}());\n\n/**\n * The ObservablePoint object represents a location in a two-dimensional coordinate system, where `x` represents\n * the position on the horizontal axis and `y` represents the position on the vertical axis.\n *\n * An `ObservablePoint` is a point that triggers a callback when the point's position is changed.\n * @memberof PIXI\n */\nvar ObservablePoint = /** @class */ (function () {\n    /**\n     * Creates a new `ObservablePoint`\n     * @param cb - callback function triggered when `x` and/or `y` are changed\n     * @param scope - owner of callback\n     * @param {number} [x=0] - position of the point on the x axis\n     * @param {number} [y=0] - position of the point on the y axis\n     */\n    function ObservablePoint(cb, scope, x, y) {\n        if (x === void 0) { x = 0; }\n        if (y === void 0) { y = 0; }\n        this._x = x;\n        this._y = y;\n        this.cb = cb;\n        this.scope = scope;\n    }\n    /**\n     * Creates a clone of this point.\n     * The callback and scope params can be overridden otherwise they will default\n     * to the clone object's values.\n     * @override\n     * @param cb - The callback function triggered when `x` and/or `y` are changed\n     * @param scope - The owner of the callback\n     * @returns a copy of this observable point\n     */\n    ObservablePoint.prototype.clone = function (cb, scope) {\n        if (cb === void 0) { cb = this.cb; }\n        if (scope === void 0) { scope = this.scope; }\n        return new ObservablePoint(cb, scope, this._x, this._y);\n    };\n    /**\n     * Sets the point to a new `x` and `y` position.\n     * If `y` is omitted, both `x` and `y` will be set to `x`.\n     * @param {number} [x=0] - position of the point on the x axis\n     * @param {number} [y=x] - position of the point on the y axis\n     * @returns The observable point instance itself\n     */\n    ObservablePoint.prototype.set = function (x, y) {\n        if (x === void 0) { x = 0; }\n        if (y === void 0) { y = x; }\n        if (this._x !== x || this._y !== y) {\n            this._x = x;\n            this._y = y;\n            this.cb.call(this.scope);\n        }\n        return this;\n    };\n    /**\n     * Copies x and y from the given point (`p`)\n     * @param p - The point to copy from. Can be any of type that is or extends `IPointData`\n     * @returns The observable point instance itself\n     */\n    ObservablePoint.prototype.copyFrom = function (p) {\n        if (this._x !== p.x || this._y !== p.y) {\n            this._x = p.x;\n            this._y = p.y;\n            this.cb.call(this.scope);\n        }\n        return this;\n    };\n    /**\n     * Copies this point's x and y into that of the given point (`p`)\n     * @param p - The point to copy to. Can be any of type that is or extends `IPointData`\n     * @returns The point (`p`) with values updated\n     */\n    ObservablePoint.prototype.copyTo = function (p) {\n        p.set(this._x, this._y);\n        return p;\n    };\n    /**\n     * Accepts another point (`p`) and returns `true` if the given point is equal to this point\n     * @param p - The point to check\n     * @returns Returns `true` if both `x` and `y` are equal\n     */\n    ObservablePoint.prototype.equals = function (p) {\n        return (p.x === this._x) && (p.y === this._y);\n    };\n    ObservablePoint.prototype.toString = function () {\n        return \"[@pixi/math:ObservablePoint x=\" + 0 + \" y=\" + 0 + \" scope=\" + this.scope + \"]\";\n    };\n    Object.defineProperty(ObservablePoint.prototype, \"x\", {\n        /** Position of the observable point on the x axis. */\n        get: function () {\n            return this._x;\n        },\n        set: function (value) {\n            if (this._x !== value) {\n                this._x = value;\n                this.cb.call(this.scope);\n            }\n        },\n        enumerable: false,\n        configurable: true\n    });\n    Object.defineProperty(ObservablePoint.prototype, \"y\", {\n        /** Position of the observable point on the y axis. */\n        get: function () {\n            return this._y;\n        },\n        set: function (value) {\n            if (this._y !== value) {\n                this._y = value;\n                this.cb.call(this.scope);\n            }\n        },\n        enumerable: false,\n        configurable: true\n    });\n    return ObservablePoint;\n}());\n\n/**\n * The PixiJS Matrix as a class makes it a lot faster.\n *\n * Here is a representation of it:\n * ```js\n * | a | c | tx|\n * | b | d | ty|\n * | 0 | 0 | 1 |\n * ```\n * @memberof PIXI\n */\nvar Matrix = /** @class */ (function () {\n    /**\n     * @param a - x scale\n     * @param b - y skew\n     * @param c - x skew\n     * @param d - y scale\n     * @param tx - x translation\n     * @param ty - y translation\n     */\n    function Matrix(a, b, c, d, tx, ty) {\n        if (a === void 0) { a = 1; }\n        if (b === void 0) { b = 0; }\n        if (c === void 0) { c = 0; }\n        if (d === void 0) { d = 1; }\n        if (tx === void 0) { tx = 0; }\n        if (ty === void 0) { ty = 0; }\n        this.array = null;\n        this.a = a;\n        this.b = b;\n        this.c = c;\n        this.d = d;\n        this.tx = tx;\n        this.ty = ty;\n    }\n    /**\n     * Creates a Matrix object based on the given array. The Element to Matrix mapping order is as follows:\n     *\n     * a = array[0]\n     * b = array[1]\n     * c = array[3]\n     * d = array[4]\n     * tx = array[2]\n     * ty = array[5]\n     * @param array - The array that the matrix will be populated from.\n     */\n    Matrix.prototype.fromArray = function (array) {\n        this.a = array[0];\n        this.b = array[1];\n        this.c = array[3];\n        this.d = array[4];\n        this.tx = array[2];\n        this.ty = array[5];\n    };\n    /**\n     * Sets the matrix properties.\n     * @param a - Matrix component\n     * @param b - Matrix component\n     * @param c - Matrix component\n     * @param d - Matrix component\n     * @param tx - Matrix component\n     * @param ty - Matrix component\n     * @returns This matrix. Good for chaining method calls.\n     */\n    Matrix.prototype.set = function (a, b, c, d, tx, ty) {\n        this.a = a;\n        this.b = b;\n        this.c = c;\n        this.d = d;\n        this.tx = tx;\n        this.ty = ty;\n        return this;\n    };\n    /**\n     * Creates an array from the current Matrix object.\n     * @param transpose - Whether we need to transpose the matrix or not\n     * @param [out=new Float32Array(9)] - If provided the array will be assigned to out\n     * @returns The newly created array which contains the matrix\n     */\n    Matrix.prototype.toArray = function (transpose, out) {\n        if (!this.array) {\n            this.array = new Float32Array(9);\n        }\n        var array = out || this.array;\n        if (transpose) {\n            array[0] = this.a;\n            array[1] = this.b;\n            array[2] = 0;\n            array[3] = this.c;\n            array[4] = this.d;\n            array[5] = 0;\n            array[6] = this.tx;\n            array[7] = this.ty;\n            array[8] = 1;\n        }\n        else {\n            array[0] = this.a;\n            array[1] = this.c;\n            array[2] = this.tx;\n            array[3] = this.b;\n            array[4] = this.d;\n            array[5] = this.ty;\n            array[6] = 0;\n            array[7] = 0;\n            array[8] = 1;\n        }\n        return array;\n    };\n    /**\n     * Get a new position with the current transformation applied.\n     * Can be used to go from a child's coordinate space to the world coordinate space. (e.g. rendering)\n     * @param pos - The origin\n     * @param {PIXI.Point} [newPos] - The point that the new position is assigned to (allowed to be same as input)\n     * @returns {PIXI.Point} The new point, transformed through this matrix\n     */\n    Matrix.prototype.apply = function (pos, newPos) {\n        newPos = (newPos || new Point());\n        var x = pos.x;\n        var y = pos.y;\n        newPos.x = (this.a * x) + (this.c * y) + this.tx;\n        newPos.y = (this.b * x) + (this.d * y) + this.ty;\n        return newPos;\n    };\n    /**\n     * Get a new position with the inverse of the current transformation applied.\n     * Can be used to go from the world coordinate space to a child's coordinate space. (e.g. input)\n     * @param pos - The origin\n     * @param {PIXI.Point} [newPos] - The point that the new position is assigned to (allowed to be same as input)\n     * @returns {PIXI.Point} The new point, inverse-transformed through this matrix\n     */\n    Matrix.prototype.applyInverse = function (pos, newPos) {\n        newPos = (newPos || new Point());\n        var id = 1 / ((this.a * this.d) + (this.c * -this.b));\n        var x = pos.x;\n        var y = pos.y;\n        newPos.x = (this.d * id * x) + (-this.c * id * y) + (((this.ty * this.c) - (this.tx * this.d)) * id);\n        newPos.y = (this.a * id * y) + (-this.b * id * x) + (((-this.ty * this.a) + (this.tx * this.b)) * id);\n        return newPos;\n    };\n    /**\n     * Translates the matrix on the x and y.\n     * @param x - How much to translate x by\n     * @param y - How much to translate y by\n     * @returns This matrix. Good for chaining method calls.\n     */\n    Matrix.prototype.translate = function (x, y) {\n        this.tx += x;\n        this.ty += y;\n        return this;\n    };\n    /**\n     * Applies a scale transformation to the matrix.\n     * @param x - The amount to scale horizontally\n     * @param y - The amount to scale vertically\n     * @returns This matrix. Good for chaining method calls.\n     */\n    Matrix.prototype.scale = function (x, y) {\n        this.a *= x;\n        this.d *= y;\n        this.c *= x;\n        this.b *= y;\n        this.tx *= x;\n        this.ty *= y;\n        return this;\n    };\n    /**\n     * Applies a rotation transformation to the matrix.\n     * @param angle - The angle in radians.\n     * @returns This matrix. Good for chaining method calls.\n     */\n    Matrix.prototype.rotate = function (angle) {\n        var cos = Math.cos(angle);\n        var sin = Math.sin(angle);\n        var a1 = this.a;\n        var c1 = this.c;\n        var tx1 = this.tx;\n        this.a = (a1 * cos) - (this.b * sin);\n        this.b = (a1 * sin) + (this.b * cos);\n        this.c = (c1 * cos) - (this.d * sin);\n        this.d = (c1 * sin) + (this.d * cos);\n        this.tx = (tx1 * cos) - (this.ty * sin);\n        this.ty = (tx1 * sin) + (this.ty * cos);\n        return this;\n    };\n    /**\n     * Appends the given Matrix to this Matrix.\n     * @param matrix - The matrix to append.\n     * @returns This matrix. Good for chaining method calls.\n     */\n    Matrix.prototype.append = function (matrix) {\n        var a1 = this.a;\n        var b1 = this.b;\n        var c1 = this.c;\n        var d1 = this.d;\n        this.a = (matrix.a * a1) + (matrix.b * c1);\n        this.b = (matrix.a * b1) + (matrix.b * d1);\n        this.c = (matrix.c * a1) + (matrix.d * c1);\n        this.d = (matrix.c * b1) + (matrix.d * d1);\n        this.tx = (matrix.tx * a1) + (matrix.ty * c1) + this.tx;\n        this.ty = (matrix.tx * b1) + (matrix.ty * d1) + this.ty;\n        return this;\n    };\n    /**\n     * Sets the matrix based on all the available properties\n     * @param x - Position on the x axis\n     * @param y - Position on the y axis\n     * @param pivotX - Pivot on the x axis\n     * @param pivotY - Pivot on the y axis\n     * @param scaleX - Scale on the x axis\n     * @param scaleY - Scale on the y axis\n     * @param rotation - Rotation in radians\n     * @param skewX - Skew on the x axis\n     * @param skewY - Skew on the y axis\n     * @returns This matrix. Good for chaining method calls.\n     */\n    Matrix.prototype.setTransform = function (x, y, pivotX, pivotY, scaleX, scaleY, rotation, skewX, skewY) {\n        this.a = Math.cos(rotation + skewY) * scaleX;\n        this.b = Math.sin(rotation + skewY) * scaleX;\n        this.c = -Math.sin(rotation - skewX) * scaleY;\n        this.d = Math.cos(rotation - skewX) * scaleY;\n        this.tx = x - ((pivotX * this.a) + (pivotY * this.c));\n        this.ty = y - ((pivotX * this.b) + (pivotY * this.d));\n        return this;\n    };\n    /**\n     * Prepends the given Matrix to this Matrix.\n     * @param matrix - The matrix to prepend\n     * @returns This matrix. Good for chaining method calls.\n     */\n    Matrix.prototype.prepend = function (matrix) {\n        var tx1 = this.tx;\n        if (matrix.a !== 1 || matrix.b !== 0 || matrix.c !== 0 || matrix.d !== 1) {\n            var a1 = this.a;\n            var c1 = this.c;\n            this.a = (a1 * matrix.a) + (this.b * matrix.c);\n            this.b = (a1 * matrix.b) + (this.b * matrix.d);\n            this.c = (c1 * matrix.a) + (this.d * matrix.c);\n            this.d = (c1 * matrix.b) + (this.d * matrix.d);\n        }\n        this.tx = (tx1 * matrix.a) + (this.ty * matrix.c) + matrix.tx;\n        this.ty = (tx1 * matrix.b) + (this.ty * matrix.d) + matrix.ty;\n        return this;\n    };\n    /**\n     * Decomposes the matrix (x, y, scaleX, scaleY, and rotation) and sets the properties on to a transform.\n     * @param transform - The transform to apply the properties to.\n     * @returns The transform with the newly applied properties\n     */\n    Matrix.prototype.decompose = function (transform) {\n        // sort out rotation / skew..\n        var a = this.a;\n        var b = this.b;\n        var c = this.c;\n        var d = this.d;\n        var pivot = transform.pivot;\n        var skewX = -Math.atan2(-c, d);\n        var skewY = Math.atan2(b, a);\n        var delta = Math.abs(skewX + skewY);\n        if (delta < 0.00001 || Math.abs(PI_2 - delta) < 0.00001) {\n            transform.rotation = skewY;\n            transform.skew.x = transform.skew.y = 0;\n        }\n        else {\n            transform.rotation = 0;\n            transform.skew.x = skewX;\n            transform.skew.y = skewY;\n        }\n        // next set scale\n        transform.scale.x = Math.sqrt((a * a) + (b * b));\n        transform.scale.y = Math.sqrt((c * c) + (d * d));\n        // next set position\n        transform.position.x = this.tx + ((pivot.x * a) + (pivot.y * c));\n        transform.position.y = this.ty + ((pivot.x * b) + (pivot.y * d));\n        return transform;\n    };\n    /**\n     * Inverts this matrix\n     * @returns This matrix. Good for chaining method calls.\n     */\n    Matrix.prototype.invert = function () {\n        var a1 = this.a;\n        var b1 = this.b;\n        var c1 = this.c;\n        var d1 = this.d;\n        var tx1 = this.tx;\n        var n = (a1 * d1) - (b1 * c1);\n        this.a = d1 / n;\n        this.b = -b1 / n;\n        this.c = -c1 / n;\n        this.d = a1 / n;\n        this.tx = ((c1 * this.ty) - (d1 * tx1)) / n;\n        this.ty = -((a1 * this.ty) - (b1 * tx1)) / n;\n        return this;\n    };\n    /**\n     * Resets this Matrix to an identity (default) matrix.\n     * @returns This matrix. Good for chaining method calls.\n     */\n    Matrix.prototype.identity = function () {\n        this.a = 1;\n        this.b = 0;\n        this.c = 0;\n        this.d = 1;\n        this.tx = 0;\n        this.ty = 0;\n        return this;\n    };\n    /**\n     * Creates a new Matrix object with the same values as this one.\n     * @returns A copy of this matrix. Good for chaining method calls.\n     */\n    Matrix.prototype.clone = function () {\n        var matrix = new Matrix();\n        matrix.a = this.a;\n        matrix.b = this.b;\n        matrix.c = this.c;\n        matrix.d = this.d;\n        matrix.tx = this.tx;\n        matrix.ty = this.ty;\n        return matrix;\n    };\n    /**\n     * Changes the values of the given matrix to be the same as the ones in this matrix\n     * @param matrix - The matrix to copy to.\n     * @returns The matrix given in parameter with its values updated.\n     */\n    Matrix.prototype.copyTo = function (matrix) {\n        matrix.a = this.a;\n        matrix.b = this.b;\n        matrix.c = this.c;\n        matrix.d = this.d;\n        matrix.tx = this.tx;\n        matrix.ty = this.ty;\n        return matrix;\n    };\n    /**\n     * Changes the values of the matrix to be the same as the ones in given matrix\n     * @param {PIXI.Matrix} matrix - The matrix to copy from.\n     * @returns {PIXI.Matrix} this\n     */\n    Matrix.prototype.copyFrom = function (matrix) {\n        this.a = matrix.a;\n        this.b = matrix.b;\n        this.c = matrix.c;\n        this.d = matrix.d;\n        this.tx = matrix.tx;\n        this.ty = matrix.ty;\n        return this;\n    };\n    Matrix.prototype.toString = function () {\n        return \"[@pixi/math:Matrix a=\" + this.a + \" b=\" + this.b + \" c=\" + this.c + \" d=\" + this.d + \" tx=\" + this.tx + \" ty=\" + this.ty + \"]\";\n    };\n    Object.defineProperty(Matrix, \"IDENTITY\", {\n        /**\n         * A default (identity) matrix\n         * @readonly\n         */\n        get: function () {\n            return new Matrix();\n        },\n        enumerable: false,\n        configurable: true\n    });\n    Object.defineProperty(Matrix, \"TEMP_MATRIX\", {\n        /**\n         * A temp matrix\n         * @readonly\n         */\n        get: function () {\n            return new Matrix();\n        },\n        enumerable: false,\n        configurable: true\n    });\n    return Matrix;\n}());\n\n// Your friendly neighbour https://en.wikipedia.org/wiki/Dihedral_group\n/*\n * Transform matrix for operation n is:\n * | ux | vx |\n * | uy | vy |\n */\nvar ux = [1, 1, 0, -1, -1, -1, 0, 1, 1, 1, 0, -1, -1, -1, 0, 1];\nvar uy = [0, 1, 1, 1, 0, -1, -1, -1, 0, 1, 1, 1, 0, -1, -1, -1];\nvar vx = [0, -1, -1, -1, 0, 1, 1, 1, 0, 1, 1, 1, 0, -1, -1, -1];\nvar vy = [1, 1, 0, -1, -1, -1, 0, 1, -1, -1, 0, 1, 1, 1, 0, -1];\n/**\n * [Cayley Table]{@link https://en.wikipedia.org/wiki/Cayley_table}\n * for the composition of each rotation in the dihederal group D8.\n * @type {number[][]}\n * @private\n */\nvar rotationCayley = [];\n/**\n * Matrices for each `GD8Symmetry` rotation.\n * @type {PIXI.Matrix[]}\n * @private\n */\nvar rotationMatrices = [];\n/*\n * Alias for {@code Math.sign}.\n */\nvar signum = Math.sign;\n/*\n * Initializes `rotationCayley` and `rotationMatrices`. It is called\n * only once below.\n */\nfunction init() {\n    for (var i = 0; i < 16; i++) {\n        var row = [];\n        rotationCayley.push(row);\n        for (var j = 0; j < 16; j++) {\n            /* Multiplies rotation matrices i and j. */\n            var _ux = signum((ux[i] * ux[j]) + (vx[i] * uy[j]));\n            var _uy = signum((uy[i] * ux[j]) + (vy[i] * uy[j]));\n            var _vx = signum((ux[i] * vx[j]) + (vx[i] * vy[j]));\n            var _vy = signum((uy[i] * vx[j]) + (vy[i] * vy[j]));\n            /* Finds rotation matrix matching the product and pushes it. */\n            for (var k = 0; k < 16; k++) {\n                if (ux[k] === _ux && uy[k] === _uy\n                    && vx[k] === _vx && vy[k] === _vy) {\n                    row.push(k);\n                    break;\n                }\n            }\n        }\n    }\n    for (var i = 0; i < 16; i++) {\n        var mat = new Matrix();\n        mat.set(ux[i], uy[i], vx[i], vy[i], 0, 0);\n        rotationMatrices.push(mat);\n    }\n}\ninit();\n/**\n * @memberof PIXI\n * @typedef {number} GD8Symmetry\n * @see PIXI.groupD8\n */\n/**\n * Implements the dihedral group D8, which is similar to\n * [group D4]{@link http://mathworld.wolfram.com/DihedralGroupD4.html};\n * D8 is the same but with diagonals, and it is used for texture\n * rotations.\n *\n * The directions the U- and V- axes after rotation\n * of an angle of `a: GD8Constant` are the vectors `(uX(a), uY(a))`\n * and `(vX(a), vY(a))`. These aren't necessarily unit vectors.\n *\n * **Origin:**<br>\n *  This is the small part of gameofbombs.com portal system. It works.\n * @see PIXI.groupD8.E\n * @see PIXI.groupD8.SE\n * @see PIXI.groupD8.S\n * @see PIXI.groupD8.SW\n * @see PIXI.groupD8.W\n * @see PIXI.groupD8.NW\n * @see PIXI.groupD8.N\n * @see PIXI.groupD8.NE\n * @author Ivan @ivanpopelyshev\n * @namespace PIXI.groupD8\n * @memberof PIXI\n */\nvar groupD8 = {\n    /**\n     * | Rotation | Direction |\n     * |----------|-----------|\n     * | 0°       | East      |\n     * @memberof PIXI.groupD8\n     * @constant {PIXI.GD8Symmetry}\n     */\n    E: 0,\n    /**\n     * | Rotation | Direction |\n     * |----------|-----------|\n     * | 45°↻     | Southeast |\n     * @memberof PIXI.groupD8\n     * @constant {PIXI.GD8Symmetry}\n     */\n    SE: 1,\n    /**\n     * | Rotation | Direction |\n     * |----------|-----------|\n     * | 90°↻     | South     |\n     * @memberof PIXI.groupD8\n     * @constant {PIXI.GD8Symmetry}\n     */\n    S: 2,\n    /**\n     * | Rotation | Direction |\n     * |----------|-----------|\n     * | 135°↻    | Southwest |\n     * @memberof PIXI.groupD8\n     * @constant {PIXI.GD8Symmetry}\n     */\n    SW: 3,\n    /**\n     * | Rotation | Direction |\n     * |----------|-----------|\n     * | 180°     | West      |\n     * @memberof PIXI.groupD8\n     * @constant {PIXI.GD8Symmetry}\n     */\n    W: 4,\n    /**\n     * | Rotation    | Direction    |\n     * |-------------|--------------|\n     * | -135°/225°↻ | Northwest    |\n     * @memberof PIXI.groupD8\n     * @constant {PIXI.GD8Symmetry}\n     */\n    NW: 5,\n    /**\n     * | Rotation    | Direction    |\n     * |-------------|--------------|\n     * | -90°/270°↻  | North        |\n     * @memberof PIXI.groupD8\n     * @constant {PIXI.GD8Symmetry}\n     */\n    N: 6,\n    /**\n     * | Rotation    | Direction    |\n     * |-------------|--------------|\n     * | -45°/315°↻  | Northeast    |\n     * @memberof PIXI.groupD8\n     * @constant {PIXI.GD8Symmetry}\n     */\n    NE: 7,\n    /**\n     * Reflection about Y-axis.\n     * @memberof PIXI.groupD8\n     * @constant {PIXI.GD8Symmetry}\n     */\n    MIRROR_VERTICAL: 8,\n    /**\n     * Reflection about the main diagonal.\n     * @memberof PIXI.groupD8\n     * @constant {PIXI.GD8Symmetry}\n     */\n    MAIN_DIAGONAL: 10,\n    /**\n     * Reflection about X-axis.\n     * @memberof PIXI.groupD8\n     * @constant {PIXI.GD8Symmetry}\n     */\n    MIRROR_HORIZONTAL: 12,\n    /**\n     * Reflection about reverse diagonal.\n     * @memberof PIXI.groupD8\n     * @constant {PIXI.GD8Symmetry}\n     */\n    REVERSE_DIAGONAL: 14,\n    /**\n     * @memberof PIXI.groupD8\n     * @param {PIXI.GD8Symmetry} ind - sprite rotation angle.\n     * @returns {PIXI.GD8Symmetry} The X-component of the U-axis\n     *    after rotating the axes.\n     */\n    uX: function (ind) { return ux[ind]; },\n    /**\n     * @memberof PIXI.groupD8\n     * @param {PIXI.GD8Symmetry} ind - sprite rotation angle.\n     * @returns {PIXI.GD8Symmetry} The Y-component of the U-axis\n     *    after rotating the axes.\n     */\n    uY: function (ind) { return uy[ind]; },\n    /**\n     * @memberof PIXI.groupD8\n     * @param {PIXI.GD8Symmetry} ind - sprite rotation angle.\n     * @returns {PIXI.GD8Symmetry} The X-component of the V-axis\n     *    after rotating the axes.\n     */\n    vX: function (ind) { return vx[ind]; },\n    /**\n     * @memberof PIXI.groupD8\n     * @param {PIXI.GD8Symmetry} ind - sprite rotation angle.\n     * @returns {PIXI.GD8Symmetry} The Y-component of the V-axis\n     *    after rotating the axes.\n     */\n    vY: function (ind) { return vy[ind]; },\n    /**\n     * @memberof PIXI.groupD8\n     * @param {PIXI.GD8Symmetry} rotation - symmetry whose opposite\n     *   is needed. Only rotations have opposite symmetries while\n     *   reflections don't.\n     * @returns {PIXI.GD8Symmetry} The opposite symmetry of `rotation`\n     */\n    inv: function (rotation) {\n        if (rotation & 8) // true only if between 8 & 15 (reflections)\n         {\n            return rotation & 15; // or rotation % 16\n        }\n        return (-rotation) & 7; // or (8 - rotation) % 8\n    },\n    /**\n     * Composes the two D8 operations.\n     *\n     * Taking `^` as reflection:\n     *\n     * |       | E=0 | S=2 | W=4 | N=6 | E^=8 | S^=10 | W^=12 | N^=14 |\n     * |-------|-----|-----|-----|-----|------|-------|-------|-------|\n     * | E=0   | E   | S   | W   | N   | E^   | S^    | W^    | N^    |\n     * | S=2   | S   | W   | N   | E   | S^   | W^    | N^    | E^    |\n     * | W=4   | W   | N   | E   | S   | W^   | N^    | E^    | S^    |\n     * | N=6   | N   | E   | S   | W   | N^   | E^    | S^    | W^    |\n     * | E^=8  | E^  | N^  | W^  | S^  | E    | N     | W     | S     |\n     * | S^=10 | S^  | E^  | N^  | W^  | S    | E     | N     | W     |\n     * | W^=12 | W^  | S^  | E^  | N^  | W    | S     | E     | N     |\n     * | N^=14 | N^  | W^  | S^  | E^  | N    | W     | S     | E     |\n     *\n     * [This is a Cayley table]{@link https://en.wikipedia.org/wiki/Cayley_table}\n     * @memberof PIXI.groupD8\n     * @param {PIXI.GD8Symmetry} rotationSecond - Second operation, which\n     *   is the row in the above cayley table.\n     * @param {PIXI.GD8Symmetry} rotationFirst - First operation, which\n     *   is the column in the above cayley table.\n     * @returns {PIXI.GD8Symmetry} Composed operation\n     */\n    add: function (rotationSecond, rotationFirst) { return (rotationCayley[rotationSecond][rotationFirst]); },\n    /**\n     * Reverse of `add`.\n     * @memberof PIXI.groupD8\n     * @param {PIXI.GD8Symmetry} rotationSecond - Second operation\n     * @param {PIXI.GD8Symmetry} rotationFirst - First operation\n     * @returns {PIXI.GD8Symmetry} Result\n     */\n    sub: function (rotationSecond, rotationFirst) { return (rotationCayley[rotationSecond][groupD8.inv(rotationFirst)]); },\n    /**\n     * Adds 180 degrees to rotation, which is a commutative\n     * operation.\n     * @memberof PIXI.groupD8\n     * @param {number} rotation - The number to rotate.\n     * @returns {number} Rotated number\n     */\n    rotate180: function (rotation) { return rotation ^ 4; },\n    /**\n     * Checks if the rotation angle is vertical, i.e. south\n     * or north. It doesn't work for reflections.\n     * @memberof PIXI.groupD8\n     * @param {PIXI.GD8Symmetry} rotation - The number to check.\n     * @returns {boolean} Whether or not the direction is vertical\n     */\n    isVertical: function (rotation) { return (rotation & 3) === 2; },\n    /**\n     * Approximates the vector `V(dx,dy)` into one of the\n     * eight directions provided by `groupD8`.\n     * @memberof PIXI.groupD8\n     * @param {number} dx - X-component of the vector\n     * @param {number} dy - Y-component of the vector\n     * @returns {PIXI.GD8Symmetry} Approximation of the vector into\n     *  one of the eight symmetries.\n     */\n    byDirection: function (dx, dy) {\n        if (Math.abs(dx) * 2 <= Math.abs(dy)) {\n            if (dy >= 0) {\n                return groupD8.S;\n            }\n            return groupD8.N;\n        }\n        else if (Math.abs(dy) * 2 <= Math.abs(dx)) {\n            if (dx > 0) {\n                return groupD8.E;\n            }\n            return groupD8.W;\n        }\n        else if (dy > 0) {\n            if (dx > 0) {\n                return groupD8.SE;\n            }\n            return groupD8.SW;\n        }\n        else if (dx > 0) {\n            return groupD8.NE;\n        }\n        return groupD8.NW;\n    },\n    /**\n     * Helps sprite to compensate texture packer rotation.\n     * @memberof PIXI.groupD8\n     * @param {PIXI.Matrix} matrix - sprite world matrix\n     * @param {PIXI.GD8Symmetry} rotation - The rotation factor to use.\n     * @param {number} tx - sprite anchoring\n     * @param {number} ty - sprite anchoring\n     */\n    matrixAppendRotationInv: function (matrix, rotation, tx, ty) {\n        if (tx === void 0) { tx = 0; }\n        if (ty === void 0) { ty = 0; }\n        // Packer used \"rotation\", we use \"inv(rotation)\"\n        var mat = rotationMatrices[groupD8.inv(rotation)];\n        mat.tx = tx;\n        mat.ty = ty;\n        matrix.append(mat);\n    },\n};\n\n/**\n * Transform that takes care about its versions.\n * @memberof PIXI\n */\nvar Transform = /** @class */ (function () {\n    function Transform() {\n        this.worldTransform = new Matrix();\n        this.localTransform = new Matrix();\n        this.position = new ObservablePoint(this.onChange, this, 0, 0);\n        this.scale = new ObservablePoint(this.onChange, this, 1, 1);\n        this.pivot = new ObservablePoint(this.onChange, this, 0, 0);\n        this.skew = new ObservablePoint(this.updateSkew, this, 0, 0);\n        this._rotation = 0;\n        this._cx = 1;\n        this._sx = 0;\n        this._cy = 0;\n        this._sy = 1;\n        this._localID = 0;\n        this._currentLocalID = 0;\n        this._worldID = 0;\n        this._parentID = 0;\n    }\n    /** Called when a value changes. */\n    Transform.prototype.onChange = function () {\n        this._localID++;\n    };\n    /** Called when the skew or the rotation changes. */\n    Transform.prototype.updateSkew = function () {\n        this._cx = Math.cos(this._rotation + this.skew.y);\n        this._sx = Math.sin(this._rotation + this.skew.y);\n        this._cy = -Math.sin(this._rotation - this.skew.x); // cos, added PI/2\n        this._sy = Math.cos(this._rotation - this.skew.x); // sin, added PI/2\n        this._localID++;\n    };\n    Transform.prototype.toString = function () {\n        return \"[@pixi/math:Transform \"\n            + (\"position=(\" + this.position.x + \", \" + this.position.y + \") \")\n            + (\"rotation=\" + this.rotation + \" \")\n            + (\"scale=(\" + this.scale.x + \", \" + this.scale.y + \") \")\n            + (\"skew=(\" + this.skew.x + \", \" + this.skew.y + \") \")\n            + \"]\";\n    };\n    /** Updates the local transformation matrix. */\n    Transform.prototype.updateLocalTransform = function () {\n        var lt = this.localTransform;\n        if (this._localID !== this._currentLocalID) {\n            // get the matrix values of the displayobject based on its transform properties..\n            lt.a = this._cx * this.scale.x;\n            lt.b = this._sx * this.scale.x;\n            lt.c = this._cy * this.scale.y;\n            lt.d = this._sy * this.scale.y;\n            lt.tx = this.position.x - ((this.pivot.x * lt.a) + (this.pivot.y * lt.c));\n            lt.ty = this.position.y - ((this.pivot.x * lt.b) + (this.pivot.y * lt.d));\n            this._currentLocalID = this._localID;\n            // force an update..\n            this._parentID = -1;\n        }\n    };\n    /**\n     * Updates the local and the world transformation matrices.\n     * @param parentTransform - The parent transform\n     */\n    Transform.prototype.updateTransform = function (parentTransform) {\n        var lt = this.localTransform;\n        if (this._localID !== this._currentLocalID) {\n            // get the matrix values of the displayobject based on its transform properties..\n            lt.a = this._cx * this.scale.x;\n            lt.b = this._sx * this.scale.x;\n            lt.c = this._cy * this.scale.y;\n            lt.d = this._sy * this.scale.y;\n            lt.tx = this.position.x - ((this.pivot.x * lt.a) + (this.pivot.y * lt.c));\n            lt.ty = this.position.y - ((this.pivot.x * lt.b) + (this.pivot.y * lt.d));\n            this._currentLocalID = this._localID;\n            // force an update..\n            this._parentID = -1;\n        }\n        if (this._parentID !== parentTransform._worldID) {\n            // concat the parent matrix with the objects transform.\n            var pt = parentTransform.worldTransform;\n            var wt = this.worldTransform;\n            wt.a = (lt.a * pt.a) + (lt.b * pt.c);\n            wt.b = (lt.a * pt.b) + (lt.b * pt.d);\n            wt.c = (lt.c * pt.a) + (lt.d * pt.c);\n            wt.d = (lt.c * pt.b) + (lt.d * pt.d);\n            wt.tx = (lt.tx * pt.a) + (lt.ty * pt.c) + pt.tx;\n            wt.ty = (lt.tx * pt.b) + (lt.ty * pt.d) + pt.ty;\n            this._parentID = parentTransform._worldID;\n            // update the id of the transform..\n            this._worldID++;\n        }\n    };\n    /**\n     * Decomposes a matrix and sets the transforms properties based on it.\n     * @param matrix - The matrix to decompose\n     */\n    Transform.prototype.setFromMatrix = function (matrix) {\n        matrix.decompose(this);\n        this._localID++;\n    };\n    Object.defineProperty(Transform.prototype, \"rotation\", {\n        /** The rotation of the object in radians. */\n        get: function () {\n            return this._rotation;\n        },\n        set: function (value) {\n            if (this._rotation !== value) {\n                this._rotation = value;\n                this.updateSkew();\n            }\n        },\n        enumerable: false,\n        configurable: true\n    });\n    /** A default (identity) transform. */\n    Transform.IDENTITY = new Transform();\n    return Transform;\n}());\n\n\n//# sourceMappingURL=math.mjs.map\n\n\n//# sourceURL=webpack://sv-editor2/./node_modules/@pixi/math/dist/esm/math.mjs?");

/***/ })

/******/ 	});
/************************************************************************/
/******/ 	// The module cache
/******/ 	var __webpack_module_cache__ = {};
/******/ 	
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/ 		// Check if module is in cache
/******/ 		var cachedModule = __webpack_module_cache__[moduleId];
/******/ 		if (cachedModule !== undefined) {
/******/ 			return cachedModule.exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = __webpack_module_cache__[moduleId] = {
/******/ 			// no module.id needed
/******/ 			// no module.loaded needed
/******/ 			exports: {}
/******/ 		};
/******/ 	
/******/ 		// Execute the module function
/******/ 		__webpack_modules__[moduleId](module, module.exports, __webpack_require__);
/******/ 	
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/ 	
/************************************************************************/
/******/ 	/* webpack/runtime/define property getters */
/******/ 	(() => {
/******/ 		// define getter functions for harmony exports
/******/ 		__webpack_require__.d = (exports, definition) => {
/******/ 			for(var key in definition) {
/******/ 				if(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {
/******/ 					Object.defineProperty(exports, key, { enumerable: true, get: definition[key] });
/******/ 				}
/******/ 			}
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/hasOwnProperty shorthand */
/******/ 	(() => {
/******/ 		__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/make namespace object */
/******/ 	(() => {
/******/ 		// define __esModule on exports
/******/ 		__webpack_require__.r = (exports) => {
/******/ 			if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 				Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 			}
/******/ 			Object.defineProperty(exports, '__esModule', { value: true });
/******/ 		};
/******/ 	})();
/******/ 	
/************************************************************************/
/******/ 	
/******/ 	// startup
/******/ 	// Load entry module and return exports
/******/ 	// This entry module can't be inlined because the eval devtool is used.
/******/ 	var __webpack_exports__ = __webpack_require__("./parser.js");
/******/ 	
/******/ })()
;